¬© Casa do C√≥digo
Todos os direitos reservados e protegidos pela Lei n¬∫9.610, de
10/02/1998.
Nenhuma parte deste livro poder√° ser reproduzida, nem transmitida, sem
autoriza√ß√£o pr√©via por escrito da editora, sejam quais forem os meios:
fotogr√°Ô¨Åcos, eletr√¥nicos, mec√¢nicos, grava√ß√£o ou quaisquer outros.
Casa do C√≥digo
Livros para o programador
Rua Vergueiro, 3185 - 8¬∫ andar
04101-300 ‚Äì Vila Mariana ‚Äì S√£o Paulo ‚Äì SP ‚Äì Brasil

Casa do C√≥digo

Sum√°rio

Sum√°rio
1

2

3

Introdu√ß√£o

1

1.1

Mantendo o hist√≥rico do c√≥digo . . . . . . . . . . . . . . . . .

1

1.2

Trabalhando em equipe . . . . . . . . . . . . . . . . . . . . . .

2

1.3

Sistemas de controle de vers√£o . . . . . . . . . . . . . . . . . .

2

1.4

Controle de vers√£o r√°pido e confi√°vel com Git . . . . . . . . .

3

1.5

Hospedando c√≥digo no GitHub . . . . . . . . . . . . . . . . .

3

1.6

O processo de escrita desse livro . . . . . . . . . . . . . . . . .

4

Tour pr√°tico

5

2.1

Instalando e configurando o Git . . . . . . . . . . . . . . . . .

5

2.2

Criando um arquivo texto para versionarmos . . . . . . . . .

7

2.3

Versionando seu c√≥digo com Git . . . . . . . . . . . . . . . .

8

2.4

Compartilhando seu c√≥digo atrav√©s do GitHub . . . . . . . .

12

Trabalhando com reposit√≥rio local

19

3.1

Criando um reposit√≥rio local . . . . . . . . . . . . . . . . . . .

20

3.2

Rastreando arquivos . . . . . . . . . . . . . . . . . . . . . . . .

22

3.3

Gravando arquivos no reposit√≥rio . . . . . . . . . . . . . . . .

29

3.4

Verificando o hist√≥rico do seu reposit√≥rio . . . . . . . . . . .

36

3.5

Verificando mudan√ßas nos arquivos rastreados . . . . . . . .

39

3.6

Removendo arquivos do reposit√≥rio . . . . . . . . . . . . . . .

47

3.7

Renomeando e movendo arquivos . . . . . . . . . . . . . . . .

49

3.8

Desfazendo mudan√ßas . . . . . . . . . . . . . . . . . . . . . .

52
i

Casa do C√≥digo

Sum√°rio

4 Trabalhando com reposit√≥rio remoto
4.1 Reposit√≥rio remoto . . . . . . . . . . . . . . .
4.2 Adicionando o reposit√≥rio remoto . . . . . .
4.3 Enviando commits para o reposit√≥rio remoto
4.4 Clonando o reposit√≥rio remoto . . . . . . . .
4.5 Sincronizando o reposit√≥rio local . . . . . . .
4.6 Protocolos suportados pelo Git . . . . . . . .
5

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

61
62
63
65
66
67
68

Hospedando o reposit√≥rio no GitHub
5.1 Servi√ßos de hospedagem de projetos . . . . . . . . .
5.2 GitHub: a rede social dos desenvolvedores . . . . . .
5.3 Encontrando projetos e visualizando o c√≥digo-fonte
5.4 Criando um usu√°rio no GitHub . . . . . . . . . . . .
5.5 Criando o reposit√≥rio do projeto . . . . . . . . . . .
5.6 Enviando os commits do projeto para o GitHub . . .
5.7 Clonando o reposit√≥rio hospedado no GitHub . . .
5.8 Colaborando com projetos open source . . . . . . .

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

71
72
72
74
80
83
85
86
87

.
.
.
.
.
.
.

93
94
96
98
100
101
103
105

.
.
.
.
.
.
.

113
114
116
118
121
123
127
133

.
.
.
.
.
.

.
.
.
.
.
.

6 Organizando o trabalho com branches
6.1 A branch master . . . . . . . . . . . . . . . . . . .
6.2 Criando uma branch . . . . . . . . . . . . . . . .
6.3 Trocando de branch . . . . . . . . . . . . . . . . .
6.4 Deletando uma branch . . . . . . . . . . . . . . .
6.5 Comitando c√≥digo em uma nova branch . . . . .
6.6 Voltando para o master e fazendo uma altera√ß√£o
6.7 Mesclando altera√ß√µes . . . . . . . . . . . . . . . .
7

ii

.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

Trabalhando em equipe com branches remotas
7.1 Branches remotas . . . . . . . . . . . . . . . . . . . . . . .
7.2 Compartilhando branches . . . . . . . . . . . . . . . . . .
7.3 Obtendo novas branches remotas em outros reposit√≥rios
7.4 Enviando commits para o reposit√≥rio central . . . . . . .
7.5 Obtendo commits de uma branch remota . . . . . . . . .
7.6 Mesclando branches remotas e locais . . . . . . . . . . . .
7.7 Deletando branches remotas . . . . . . . . . . . . . . . . .

.
.
.
.
.
.
.

.
.
.
.
.
.
.

Casa do C√≥digo

8

Sum√°rio

Controlando vers√µes do c√≥digo com tags
8.1 Criando, listando e deletando tags . . . . . . . . . . . . . . . .
8.2 Mais informa√ß√µes com tags anotadas . . . . . . . . . . . . . .
8.3 Compartilhando tags com a sua equipe . . . . . . . . . . . . .

137
138
139
140

9 Lidando com conflitos
9.1 Mesclando mudan√ßas em um mesmo arquivo sem conflitos .
9.2 Conflitos ap√≥s um merge com mudan√ßas em um mesmo arquivo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
9.3 Resolvendo conflitos ap√≥s um rebase . . . . . . . . . . . . . .
9.4 Usando uma ferramenta para resolver conflitos . . . . . . . .

143
144
146
150
152

10 Maneiras de trabalhar com Git
157
10.1 Utilizando s√≥ a branch master com um reposit√≥rio central . 159
10.2 Utilizando branches por funcionalidade com um reposit√≥rio
central . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 162
10.3 Utilizando branches por etapa de desenvolvimento com um
reposit√≥rio central . . . . . . . . . . . . . . . . . . . . . . . . . 167
10.4 Colaborando com projetos open source com Fork e Pull Request 173
10.5 Organizando projetos open source gigantescos com Ditador
e Tenentes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 175
11 Ap√™ndice GitHub no Windows
11.1 Instalando o GitHub for Windows . . .
11.2 Criando um novo reposit√≥rio . . . . .
11.3 Efetuando commits no reposit√≥rio . .
11.4 Detalhando os commits . . . . . . . . .
11.5 Enviando o reposit√≥rio para o GitHub
11.6 Trabalhando com branches . . . . . . .

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

179
180
186
188
190
193
195

iii

Cap√≠tulo 1

Introdu√ß√£o
1.1 Mantendo o hist√≥rico do c√≥digo
Vida de programador n√£o √© f√°cil. H√° sempre uma press√£o por entregas r√°pidas
de novas funcionalidades. Mas, apesar da pressa, √© necess√°rio prestar aten√ß√£o
no que estamos fazendo, mesmo se a altera√ß√£o for pequena. Ao mexermos
em um c√≥digo existente √© importante tomarmos cuidado para n√£o quebrar o
que j√° funciona.
Por isso, queremos mexer o m√≠nimo poss√≠vel no c√≥digo. Temos medo
de remover c√≥digo obsoleto, n√£o utilizado ou at√© mesmo comentado, mesmo
que mant√™-lo j√° nem fa√ßa sentido. N√£o √© incomum no mercado vermos c√≥digo
funcional acompanhado de centenas de linhas de c√≥digo comentado.
Sem d√∫vida, √© interessante manter o hist√≥rico do c√≥digo dos projetos,
para entendermos como chegamos at√© ali. Mas manter esse hist√≥rico junto
ao c√≥digo atual, com o decorrer do tempo, deixa nossos projetos confusos,

1.2. Trabalhando em equipe

Casa do C√≥digo

polu√≠dos com trechos e coment√°rios que poderiam ser exclu√≠dos sem afetar o
funcionamento do sistema.
Seria bom se houvesse uma maneira de navegarmos pelo c√≥digo do passado, como uma m√°quina do tempo para c√≥digo...

1.2 Trabalhando em equipe
Mas, mesmo que tiv√©ssemos essa m√°quina do tempo, temos outro problema:
muito raramente trabalhamos sozinhos.
Construir um sistema em equipe √© um grande desafio. Nosso c√≥digo tem
que se integrar de maneira transparente e sem emendas com o c√≥digo de todos
os outros membros da nossa equipe.
Como podemos detectar que estamos alterando o mesmo c√≥digo que um
colega? Como mesclar as altera√ß√µes que fizemos com a demais altera√ß√µes da
equipe? E como identificar conflitos entre essas altera√ß√µes? Fazer isso manualmente, com cadernetas ou planilhas e muita conversa, parece trabalhoso
demais e bastante suscet√≠vel a erros e esquecimentos.
Seria bom que tiv√©ssemos um rob√¥ de integra√ß√£o de c√≥digo, que fizesse
todo esse trabalho automaticamente...

1.3

Sistemas de controle de vers√£o

Existem ferramentas que funcionam como m√°quinas do tempo e rob√¥s de integra√ß√£o para o seu c√≥digo. Elas nos permitem acompanhar as altera√ß√µes desde
as vers√µes mais antigas. Tamb√©m √© poss√≠vel detectar e mesclar altera√ß√µes nos
mesmos arquivos, al√©m de identificar conflitos, tudo de maneira autom√°tica.
Essas ferramentas s√£o chamadas de sistemas de controle de vers√£o.
Nesse tipo de ferramenta, h√° um reposit√≥rio que nos permite obter qualquer vers√£o j√° existente do c√≥digo. Sempre que quisermos controlar as vers√µes
de algum arquivo, temos que informar que queremos rastre√°-lo no reposit√≥rio. A cada mudan√ßa que desejamos efetivar, devemos armazenar as altera√ß√µes nesse reposit√≥rio.
Altera√ß√µes nos mesmos arquivos s√£o mescladas de maneira autom√°tica
sempre que poss√≠vel. J√° poss√≠veis conflitos s√£o identificados a cada vez que
obtemos as mudan√ßas dos nossos colegas de time.
2

Casa do C√≥digo

Cap√≠tulo 1. Introdu√ß√£o

Desde a d√©cada de 1990, existe esse tipo de ferramenta. Alguns exemplos
de sistemas de controle de vers√£o mais antigos s√£o CVS, ClearCase, SourceSafe e SVN (que ainda √© bastante usado nas empresas).
Em meados da d√©cada de 2000, surgiram sistemas de controle de vers√£o
mais modernos, mais r√°pidos e confi√°veis, como Mercurial, Bazaar e, √© claro,
Git.

1.4 Controle de vers√£o r√°pido e confi√°vel com
Git
O Git √© um sistema de controle de vers√£o que, pela sua estrutura interna, √©
uma m√°quina do tempo extremamente r√°pida e √© um rob√¥ de integra√ß√£o bem
competente.
Foi criado em 2005 por Linus Torvalds, o mesmo criador do Linux, que
estava descontente com o BitKeeper, o sistema de controle de vers√£o utilizado
no desenvolvimento do kernel do Linux.
Hoje em dia, al√©m do kernel do Linux, a ferramenta √© utilizada em diversos outros projetos de c√≥digo aberto. O Git tamb√©m √© bastante utilizado em
empresas em todo o mundo, inclusive no Brasil.
Atualmente, conhecer bem como utilizar o Git √© uma habilidade importante para uma carreira bem-sucedida no desenvolvimento de software.

1.5

Hospedando c√≥digo no GitHub

Em 2008, foi criado o GitHub, uma aplica√ß√£o Web que possibilita a hospedagem de reposit√≥rios Git, al√©m de servir como uma rede social para programadores.
Diversos projetos de c√≥digo aberto importantes s√£o hospedados no
GitHub como jQuery, Node.js, Ruby On Rails, Jenkins, Spring, JUnit e muitos
outros.

3

1.6. O processo de escrita desse livro

Casa do C√≥digo

1.6 O processo de escrita desse livro
A utiliza√ß√£o do Git n√£o √© restrita apenas ao desenvolvimento de software, muitos administradores de rede, por exemplo, utilizam o Git para manter o hist√≥rico de evolu√ß√£o de arquivos de configura√ß√µes em servidores.
Acreditem, at√© mesmo a escrita desse livro foi feita utilizando o Git!
N√£o apenas esse, mas todos os livros da editora Casa do C√≥digo utilizam o Git como ferramenta de controle de vers√£o, para manter o hist√≥rico de
evolu√ß√£o dos cap√≠tulos. O GitHub tamb√©m √© utilizado para hospedagem dos
reposit√≥rios dos livros.

4

Cap√≠tulo 2

Tour pr√°tico
Neste cap√≠tulo, faremos um tour bem pr√°tico sobre como usar o Git para versionar nossos projetos. N√£o se preocupe com o significado dos comandos.
No decorrer do livro, todos os comandos usados aqui ser√£o explicados com
profundidade.

2.1 Instalando e configurando o Git
Antes de utilizarmos o Git, √© fundamental instal√°-lo. Escolha a seguir o Sistema Operacional apropriado e m√£os √† obra!

Instalando no Windows
Acesse a seguinte URL, fa√ßa o download e instale a √∫ltima vers√£o dispon√≠vel: http://msysgit.github.io/

2.1. Instalando e configurando o Git

Casa do C√≥digo

A instala√ß√£o √© bastante simples. Escolha as op√ß√µes padr√£o.
Ser√£o instalados alguns programas, sendo o mais importante o Git Bash,
que permite que o Git seja executado pela linha de comando no Windows.
D√™ duplo clique no √≠cone do Git Bash e ser√° aberto um terminal, com o
seguinte prompt na linha de comando:
$

Esse prompt ser√° seu amigo a partir de agora. N√£o tenha medo! Sempre
que falarmos de terminal, estaremos falando do Git Bash.

Instalando no Mac
Baixe a √∫ltima vers√£o do instalador gr√°fico do Git para Mac OS X a partir
do link: https://code.google.com/p/git-osx-installer/downloads
Abra um terminal e prepare-se para utilizar o Git!

Instalando no Linux
Para instalar o Git no Ubuntu, ou em uma outra distribui√ß√£o baseada em
Debian, execute em um terminal:
$ sudo apt-get install git

No Fedora, utilize:
$ sudo yum install git

Para as demais distribui√ß√µes do Linux, veja o comando em: http://
git-scm.com/download/linux

Configura√ß√µes b√°sicas
√â importante nos identificarmos para o Git, informando nosso nome e
e-mail. Em um terminal, execute os comandos a seguir:
$ git config --global user.name "Fulano da Silva"
$ git config --global user.email fulanodasilva.git@gmail.com

Claro, utilize seu nome e e-mail!
6

Casa do C√≥digo

Cap√≠tulo 2. Tour pr√°tico

A linha de comando
A maneira mais comum de usar Git √© pela linha de comando, acess√≠vel
atrav√©s de um terminal. √â o jeito que a maior parte dos bons profissionais
do mercado utiliza o Git e ser√° nossa escolha nesse livro.

GitHub for Windows
A maioria dos usu√°rios do Windows n√£o tem o h√°bito de utilizar o
prompt de comandos, e perfere instalar alguma aplica√ß√£o visual para trabalhar com o Git.
Uma destas aplica√ß√µes √© o GitHub for Windows, e mostraremos
como utiliz√°-la no cap√≠tulo 11.

2.2

Criando um arquivo texto para versionarmos

Antes de utilizarmos o Git, vamos criar na sua pasta pessoal, um diret√≥rio
chamado citacoes com um arquivo filmes.txt.
Dentro do arquivo filmes.txt, coloque o seguinte conte√∫do:
"N√£o h√° certezas, apenas oportunidades." (V de Vingan√ßa)
"Diga ‚Äôol√°‚Äô para meu pequeno amigo!" (Scarface)

7

2.3. Versionando seu c√≥digo com Git

Casa do C√≥digo

Pasta pessoal
A pasta pessoal (ou home directory, em ingl√™s) √© o local dos arquivos
de usu√°rio como documentos, fotos, m√∫sicas etc.
Se voc√™ n√£o souber onde √© a pasta pessoal, digite o seguinte comando
em um terminal:
$ echo ~

No Windows Vista, 7 ou 8, ser√° algo como C:\Users\Fulano\ ou,
no Git Bash, /c/Users/Fulano/.
No Windows 2000, XP ou 2003, ser√° algo como C:\Documents
and Settings\Fulano\ ou, no Git Bash, /c/Documents and
Settings/Fulano.
No Linux, ser√° /home/fulano e no Mac OS X /Users/Fulano.

2.3

Versionando seu c√≥digo com Git

Criando um reposit√≥rio
Abra um terminal e v√° at√© o diret√≥rio citacoes.
$ cd ~/citacoes

Para transformar o diret√≥rio atual em um reposit√≥rio do Git, basta executar o comando git init:
$ git init

Dever√° aparecer uma mensagem semelhante √† seguinte:
Initialized empty Git repository in /home/fulano/citacoes/.git/

Pronto, o projeto j√° √© um reposit√≥rio Git vazio.
Observe que foi criada uma pasta oculta com o nome .git.

8

Casa do C√≥digo

Cap√≠tulo 2. Tour pr√°tico

Rastreando o arquivo
Mas e o arquivo filmes.txt? Ser√° que j√° est√° versionado?
Podemos ver a situa√ß√£o dos arquivos no reposit√≥rio Git com o comando:
git status

A sa√≠da dever√° ser algo como:
# On branch master
#
# Initial commit
#
# Untracked files:
#
(use "git add <file>..." to include in what will be
committed)
#
#
filmes.txt
nothing added to commit but untracked files present (use
"git add" to track)

Observe a mensagem anterior: ela indica que o arquivo filmes.txt
ainda n√£o foi rastreado pelo Git.
Para que o arquivo seja rastreado, devemos executar o seguinte comando:
git add filmes.txt

Agora, se executarmos git status novamente, teremos a seguinte
sa√≠da:
# On branch master
#
# Initial commit
#
# Changes to be committed:
#
(use "git rm --cached <file>..." to unstage)
#
#
new file:
filmes.txt
#

9

2.3. Versionando seu c√≥digo com Git

Casa do C√≥digo

Gravando o arquivo no reposit√≥rio
O resultado anterior mostra que o conte√∫do do arquivo filmes.txt j√°
est√° sendo rastreado pelo Git, mas ainda n√£o foi gravado (ou comitado, em
uma linguagem mais t√©cnica) no reposit√≥rio.
Para gravarmos as mudan√ßas no reposit√≥rio, devemos executar o comando:
git commit -m "Arquivo inicial de citacoes"

Observe que foi invocado o comando git commit, com a op√ß√£o -m
para informar a mensagem do commit.
Deve ter aparecido algo como a seguinte mensagem:
[master (root-commit) 8666888] Arquivo inicial de citacoes
1 file changed, 2 insertions(+)
create mode 100111 filmes.txt

Se executarmos git status novamente, teremos:
# On branch master
nothing to commit, working directory clean

Alterando o arquivo
Insira mais uma linha no arquivo filmes.txt, com o conte√∫do:
"Hasta la vista, baby." (Exterminador do Futuro 2)

Depois disso, se executarmos git status novamente, podemos observar que h√° uma nova mudan√ßa para ser rastreada:
# On branch master
# Changes not staged for commit:
#
(use "git add <file>..." to update what will be committed)
#
(use "git checkout -- <file>..." to discard changes in
working directory)
#
#
modified:
filmes.txt
#
no changes added to commit (use "git add" and/or
"git commit -a")

10

Casa do C√≥digo

Cap√≠tulo 2. Tour pr√°tico

Rastreando e gravando as altera√ß√µes no reposit√≥rio
Para rastrearmos a modifica√ß√£o, devemos executar o comando git add
novamente:
git add filmes.txt

Com a modifica√ß√£o rastreada, podemos grav√°-la no reposit√≥rio, com o
comando git commit:
git commit -m "Inserindo nova citacao"

Devemos ter uma resposta parecida com:
[master 7878787] Inserindo nova citacao
1 file changed, 1 insertion(+)

Verificando altera√ß√µes realizadas
Para verificar o hist√≥rico das altera√ß√µes gravadas no reposit√≥rio, podemos
executar o comando git log:
$ git log

A sa√≠da ser√° parecida com:
commit 7878787000000000000000000000000000000000
Author: Fulano da Silva <fulanodasilva.git@gmail.com>
Date:
Fri Apr 11 21:21:31 2014 -0300
Inserindo nova citacao
commit 8666888000000000000000000000000000000000
Author: Fulano da Silva <fulanodasilva.git@gmail.com>
Date:
Fri Apr 11 21:21:31 2014 -0300
Arquivo inicial de citacoes

Pronto! Temos um reposit√≥rio criado com as altera√ß√µes no arquivo
filmes.txt devidamente gravadas. Mas e agora?

11

2.4. Compartilhando seu c√≥digo atrav√©s do GitHub

Casa do C√≥digo

2.4 Compartilhando seu c√≥digo atrav√©s do
GitHub
Para que o mundo possa descobrir nosso incr√≠vel projeto, temos que
compartilh√°-lo na internet. Para isso, utilizaremos uma aplica√ß√£o web chamada GitHub.

Criando uma conta no GitHub
O primeiro passo √© criar uma conta no GitHub. Para projetos de c√≥digo
aberto, n√£o h√° custo nenhum! Com um navegador, acesse: https://github.
com/
Preencha seu nome, e-mail e escolha uma senha.

Figura 2.1: Criando conta no GitHub

Ent√£o, selecione o plano apropriado e finalize o cadastro, clicando em
Finish Signup.

12

Casa do C√≥digo

Cap√≠tulo 2. Tour pr√°tico

Figura 2.2: Selecionando plano no GitHub

Se necess√°rio, verifique o e-mail.

Criando um reposit√≥rio no GitHub
Agora podemos criar um reposit√≥rio remoto, que ficar√° dispon√≠vel para
todos da internet. Para isso, clique no bot√£o New Repository ap√≥s acessar:
https://github.com/

13

2.4. Compartilhando seu c√≥digo atrav√©s do GitHub

Casa do C√≥digo

Figura 2.3: Novo reposit√≥rio no GitHub

No Repository name, devemos preencher o nome do reposit√≥rio remoto.
No nosso caso, vamos preencher com ‚Äúcitacoes‚Äù. Deixe o reposit√≥rio como
Public, para que qualquer pessoa consiga ver o seu c√≥digo. As demais op√ß√µes
podem ficar com os valores padr√£o. Finalmente, devemos clicar em Create
repository.

Figura 2.4: Criando reposit√≥rio no GitHub

Pronto, j√° foi criado um reposit√≥rio vazio l√° no GitHub.

14

Casa do C√≥digo

Cap√≠tulo 2. Tour pr√°tico

Apontando seu projeto para o GitHub
Devemos agora apontar o reposit√≥rio da nossa m√°quina para o reposit√≥rio do GitHub.
Em um terminal, certifique-se de estar no diret√≥rio citacoes, que tem
o reposit√≥rio local:
$ cd ~/citacoes

Ent√£o, execute o comando git remote, conforme o que segue:
$ git remote add origin https://github.com/fulanodasilva/
citacoes.git

N√£o deixe de alterar fulanodasilva para o seu usu√°rio do GitHub.
N√£o deve aparecer nenhuma mensagem.
Com o comando anterior, apontamos o nome origin para o reposit√≥rio
l√° do GitHub.

Enviando as altera√ß√µes para o GitHub
Com o reposit√≥rio remoto configurado, podemos enviar nossas mudan√ßas para o GitHub e, por consequ√™ncia, para todo o mundo.
Para isso, basta executar o comando git push, da seguinte forma:
$ git push origin master

Com o comando anterior, enviamos as altera√ß√µes para o reposit√≥rio remoto configurado com o nome origin.
Forne√ßa seu usu√°rio e senha do GitHub quando solicitado. Dever√° aparecer algo semelhante √† seguinte sa√≠da:
Username for ‚Äôhttps://github.com‚Äô: fulanodasilva
Password for ‚Äôhttps://fulanodasilva@github.com‚Äô:
Counting objects: 6, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (4/4), done.
Writing objects: 100% (6/6), 609 bytes | 0 bytes/s, done.
Total 6 (delta 1), reused 0 (delta 0)
To https://github.com/fulanodasilva/citacoes.git
* [new branch]
master -> master

15

Casa do C√≥digo

2.4. Compartilhando seu c√≥digo atrav√©s do GitHub

V√° at√© a p√°gina do seu projeto no GitHub:
fulanodasilva/citacoes

https://github.com/

Figura 2.5: P√°gina do projeto no GitHub

Observe que o arquivo que voc√™ enviou j√° est√° dispon√≠vel para qualquer
pessoa da internet. Avise seu primo, sua vizinha, todo mundo!
√â poss√≠vel ver todas as altera√ß√µes no projeto at√© agora (no caso, foram duas), atrav√©s do endere√ßo: https://github.com/fulanodasilva/citacoes/
commits/master

Figura 2.6: Listando altera√ß√µes gravadas no GitHub

Se clicarmos na √∫ltima altera√ß√£o, por exemplo, √© poss√≠vel ver as mudan√ßas
que foram feitas. Fascinante, n√£o?

16

Casa do C√≥digo

Cap√≠tulo 2. Tour pr√°tico

Figura 2.7: Detalhando uma altera√ß√£o gravada no GitHub

Obtendo projeto do GitHub
Com o projeto no GitHub, qualquer um pode acessar o c√≥digo e ver o
hist√≥rico, mesmo sem uma conta. Se a pessoa tiver cadastrada no GitHub,
ser√° poss√≠vel baixar o c√≥digo.
Vamos simular isso, baixando o c√≥digo em outro diret√≥rio do seu computador.
Na sua pasta pessoal, crie um diret√≥rio chamado projetos_git. Ent√£o,
o acesse pelo terminal:
$ cd ~/projetos_git

Para obter o c√≥digo do projeto l√° do GitHub, execute o comando git
clone conforme o seguinte:
git clone https://github.com/fulanodasilva/citacoes.git

N√£o esque√ßa de alterar fulanodasilva para o seu usu√°rio do GitHub.
Dever√° aparecer algo como:
Cloning into ‚Äôcitacoes‚Äô...
remote: Counting objects: 6, done.
remote: Compressing objects: 100% (3/3), done.
remote: Total 6 (delta 1), reused 6 (delta 1)
Unpacking objects: 100% (6/6), done.
Checking connectivity... done

17

2.4. Compartilhando seu c√≥digo atrav√©s do GitHub

Casa do C√≥digo

Observe no diret√≥rio projetos_git que foi criado um subdiret√≥rio
chamado citacoes. Dentro desse subdiret√≥rio h√° o arquivo filmes.txt,
com exatamente o mesmo conte√∫do l√° do GitHub.
H√° tamb√©m um diret√≥rio oculto chamado .git, revelando que temos
uma c√≥pia do reposit√≥rio original.
V√° at√© o subdiret√≥rio citacoes, executando o comando:
$ cd citacoes

Podemos executar o comando git log nesse novo reposit√≥rio:
$ git log

Teremos a mesma sa√≠da de antes:
commit 7878787000000000000000000000000000000000
Author: Fulano da Silva <fulanodasilva.git@gmail.com>
Date:
Fri Apr 11 21:21:31 2014 -0300
Inserindo nova citacao
commit 8666888000000000000000000000000000000000
Author: Fulano da Silva <fulanodasilva.git@gmail.com>
Date:
Fri Apr 11 21:21:31 2014 -0300
Arquivo inicial de citacoes

Se voc√™ tiver outro computador, fa√ßa o clone nele. N√£o se esque√ßa de
instalar o Git, seguindo os passos do in√≠cio deste cap√≠tulo.

Git e GitHub s√£o a mesma coisa?
N√£o. Git √© o sistema de controle de vers√µes, com o qual interagimos
na linha de comando. J√° o GitHub √© uma rede social para programadores
que disponibiliza reposit√≥rios Git acess√≠veis remotamente. O GitHub √©
muito utilizado para projetos open source que possuem v√°rios colaboradores do mundo todo. Mais adiante aprofundaremos em ambos.

18

Cap√≠tulo 3

Trabalhando com reposit√≥rio
local
A empresa M√≥veis Ecol√≥gicos nos contratou para fazer a p√°gina da empresa
na web. Conversamos com o dono da empresa, discutimos sobre o conte√∫do
b√°sico e criamos um HTML simples.
Apresentamos o resultado e nosso cliente pediu para colocarmos a p√°gina
no ar. Logo o fizemos: divers√£o e lucro!
Por√©m, a diretora de rela√ß√µes p√∫blicas da empresa n√£o gostou do texto.
Pediu para alterarmos para um texto bem maior e com mais cara de press
release. Fizemos as altera√ß√µes e publicamos.
Depois de algum tempo, o dono da empresa notou o site modificado e nos
contatou para voltarmos com a vers√£o anterior. Acontece que esquecemos de
fazer backup do arquivo. At√© tentamos usar um recuperador de arquivos ou

3.1. Criando um reposit√≥rio local

Casa do C√≥digo

lembrar o conte√∫do de cabe√ßa, mas n√£o tivemos sucesso. E agora?
Com muita relut√¢ncia, entramos em contato com o dono da empresa pedindo que o texto fosse dito novamente por telefone. Depois de alguns minutos de xingamentos e de quase perdermos o contrato, conseguimos o texto
mais uma vez.
Poxa vida... Dev√≠amos ter mantido o texto antigo comentado na p√°gina...
Mas com tantas mudan√ßas, em pouco tempo ter√≠amos mais coment√°rios do
que c√≥digo de fato.
Se tiv√©ssemos utilizado um sistema de controle de vers√£o como o Git, ter√≠amos uma m√°quina do tempo para o nosso c√≥digo. A√≠, nossa vida seria mais
f√°cil.

3.1

Criando um reposit√≥rio local

Vamos dizer que, na nossa pasta pessoal, temos um diret√≥rio chamado
moveis, com o arquivo index.html contendo o seguinte conte√∫do:
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<meta name="description" content="M√≥veis ecol√≥gicos">
<meta name="keywords" content="moveis ecologicos">
</head>
<body>
<h1>M√≥veis Ecol√≥gicos S. A.</h1>
<ul>
<li>M√≥veis de garrafas PET</li>
<li>M√≥veis de latinhas de alum√≠nio</li>
<li>M√≥veis de papel√£o</li>
</ul>
</body>
</html>

Antes de tudo, vamos entrar no diret√≥rio moveis, com o comando cd
~/moveis.
Para criar um reposit√≥rio Git nesse diret√≥rio, basta executarmos:
20

Casa do C√≥digo

Cap√≠tulo 3. Trabalhando com reposit√≥rio local

$ git init

Teremos a sa√≠da:
Initialized empty Git repository in /home/fulano/moveis/.git/

A mensagem anterior indica que transformamos o diret√≥rio moveis em
um reposit√≥rio Git.
Se listarmos os arquivos do diret√≥rio moveis com o comando ls -lha,
teremos uma resposta semelhante ao que segue:
total 36K
drwxr-xr-x 3 fulano fulano 4,0K Abr 15 21:30
drwx------ 58 fulano fulano 16K Abr 15 21:27
drwxr-xr-x 7 fulano fulano 4,0K Abr 15 21:30
-rw-r--r-- 1 fulano fulano 405 Abr 15 21:27

.
..
.git
index.html

Observem que foi criado um subdiret√≥rio oculto chamado .git na pasta
moveis. Esse subdiret√≥rio √© um reposit√≥rio do Git completo, que conter√°
todo o hist√≥rico de altera√ß√µes dos arquivos, entre outras coisas.

Podemos executar git init moveis se quisermos criar um diret√≥rio vazio que j√° √© um reposit√≥rio Git, ou seja, que j√° possui o .git.

No caso de termos outros subdiret√≥rios como js para armazenar c√≥digo
Javascript e css para armazenar arquivos CSS, todas as informa√ß√µes desses
arquivos ser√£o armazenadas no mesmo .git.
Se por algum motivo quisermos parar de usar o Git, basta remover esse
√∫nico diret√≥rio .git.
Basta o comando git init para criar um reposit√≥rio com Git, que
j√° cria localmente um reposit√≥rio completo. Isso √© bem mais simples que
diversos outros sistemas de controle de vers√£o, como o SVN, que precisavam da configura√ß√£o de um servidor.

21

3.2. Rastreando arquivos

3.2

Casa do C√≥digo

Rastreando arquivos

Para verificarmos o estado atual do nosso reposit√≥rio, devemos executar o
comando:
$ git status

Deve aparecer uma resposta parecida com:
# On branch master
#
# Initial commit
#
# Untracked files:
#
(use "git add <file>..." to include in what will be
committed)
#
#
index.html
nothing added to commit but untracked files present (use
"git add" to track)

Note que o arquivo index.html ainda n√£o est√° sendo rastreado (est√°
em Untracked files).
Para informar ao Git que o arquivo index.html deve ser rastreado, utilizamos o comando:
$ git add index.html

Pronto! Agora o Git sabe que esse arquivo √© importante e as mudan√ßas
devem ser rastreadas.
Se executarmos novamente git status, teremos a seguinte sa√≠da:
# On branch master
#
# Initial commit
#
# Changes to be committed:
#
(use "git rm --cached <file>..." to unstage)
#
#
new file:
index.html
#

22

Casa do C√≥digo

Cap√≠tulo 3. Trabalhando com reposit√≥rio local

Observe que o Git agora passou a rastrear o arquivo index.html e est√°
pronto para gravar esse arquivo no reposit√≥rio (Changes to be committed).

Rastreando v√°rios arquivos
Vamos dizer que criamos um arquivo estilos.css no diret√≥rio
moveis, com o seguinte conte√∫do:
h1 {
font-family: sans-serif;
}
li {
font-family: monospace;
}

Tamb√©m criamos um subdiret√≥rio imagens com um arquivo
logo.png, com uma imagem semelhante a: IUUQQJYBCBZDPNTUBUJDVQMPBET
QIPUPTFUUFF@QOH
Se executarmos git status, teremos:
# On branch master
#
# Initial commit
#
# Changes to be committed:
#
(use "git rm --cached <file>..." to unstage)
#
#
new file:
index.html
#
# Untracked files:
#
(use "git add <file>..." to include in what will be
committed)
#
#
estilos.css
#
imagens/

Observe que o arquivo estilos.css e o diret√≥rio imagens ainda n√£o
est√£o sendo rastreados (Untracked files).
Se quisermos rastrear todos esses arquivos, ser√° que teremos que executar
git add um por um?
23

3.2. Rastreando arquivos

Casa do C√≥digo

Na verdade, n√£o! Podemos rastrear todos esses arquivos de uma vez s√≥
com o comando:
$ git add .

O ponto do comando anterior representa todos os arquivos n√£o rastreados
do diret√≥rio atual e tamb√©m de todos os seus subdiret√≥rios.
Agora, ao executarmos git status, veremos que todos os arquivos
est√£o sendo rastreados:
# On branch master
#
# Initial commit
#
# Changes to be committed:
#
(use "git rm --cached <file>..." to unstage)
#
#
new file:
estilos.css
#
new file:
imagens/logo.png
#
new file:
index.html
#

Se quis√©ssemos ter rastreado apenas os arquivos do subdiret√≥rio
imagens, por exemplo, poder√≠amos ter executado o comando git add
imagens.

A √°rea de stage
Quando informamos para o Git que queremos rastrear um arquivo, executando git add pela primeira vez, o Git coloca esse arquivo em uma √°rea
especial do reposit√≥rio, chamada de stage.
Uma vez que um arquivo est√° na √°rea de stage, todas as mudan√ßas nesse
arquivo passam a ser examinadas.

O diret√≥rio que cont√©m nossos arquivos √© chamado de diret√≥rio de
trabalho ou working directory, em ingl√™s.

24

Casa do C√≥digo

Cap√≠tulo 3. Trabalhando com reposit√≥rio local

Vamos modificar o arquivo index.html, inserindo uma refer√™ncia ao
CSS criado anteriormente:
<!-- in√≠cio do arquivo ... -->
<head>
<!-- tags meta ... -->
<link rel="stylesheet" href="estilos.css">
</head>
<!-- restante do arquivo ... -->

A sa√≠da do git status ser√°:
# On branch master
#
# Initial commit
#
# Changes to be committed:
#
(use "git rm --cached <file>..." to unstage)
#
#
new file:
estilos.css
#
new file:
imagens/logo.png
#
new file:
index.html
#
# Changes not staged for commit:
#
(use "git add <file>..." to update what will be committed)
#
(use "git checkout -- <file>..." to discard changes in
working directory)
#
#
modified:
index.html
#

Note que o index.html continua aparecendo como um novo arquivo
rastreado (new file em Changes to be committed), indicando que ele est√° sendo
rastreado e pronto para ser gravado.
Mas observe que o arquivo index.html aparece mais uma vez, sob
Changes not staged for commit, como modificado (modified).
Isso acontece porque, uma vez que um arquivo passa a ser rastreado pelo
Git, depois de coloc√°-lo na √°rea de stage com o comando git add, cada
25

3.2. Rastreando arquivos

Casa do C√≥digo

mudan√ßa nesse arquivo √© rastreada e tamb√©m deve ser colocada na √°rea de
stage.
Para colocarmos as √∫ltimas mudan√ßas que fizemos no arquivo
index.html na √°rea de stage, devemos executar novamente:
$ git add index.html

Depois disso, ao executarmos git status, teremos:
# On branch master
#
# Initial commit
#
# Changes to be committed:
#
(use "git rm --cached <file>..." to unstage)
#
#
new file:
estilos.css
#
new file:
imagens/logo.png
#
new file:
index.html
#

Agora, tanto o arquivo original como as √∫ltimas mudan√ßas est√£o prontas
para serem gravadas no reposit√≥rio.
Uma representa√ß√£o gr√°fica das transi√ß√µes entre o diret√≥rio de trabalho e
a √°rea de stage seria:

Figura 3.1: Rastreando arquivos e mudan√ßas com Git

26

Casa do C√≥digo

Cap√≠tulo 3. Trabalhando com reposit√≥rio local

Ignorando arquivos
Suponha que temos um arquivo todo.txt que mantemos, durante o
desenvolvimento, com a lista das tarefas do dia. Suponha tamb√©m que temos
um subdiret√≥rio chamado tmp, com alguns arquivos tempor√°rios gerados ao
manipularmos imagens. N√£o faz sentido manter o hist√≥rico de ambos no Git.
Se executarmos git status, o arquivo todo.txt e o subdiret√≥rio
tmp ser√£o mostrados como arquivos ainda n√£o rastreados:
# On branch master
#
# Initial commit
#
# Changes to be committed:
#
(use "git rm --cached <file>..." to unstage)
#
#
new file:
estilos.css
#
new file:
imagens/logo.png
#
new file:
index.html
#
# Untracked files:
#
(use "git add <file>..." to include in what will be
committed)
#
#
tmp/
#
todo.txt

Ser√° que teremos sempre que lembrar de evitar o git add desses arquivos? Se for assim, n√£o poderemos mais utilizar git add ., j√° que esse
comando rastreia todos os arquivos.
Para resolver isso, o Git tem um mecanismo que permite ignorarmos arquivos. Basta criarmos um arquivo chamado .gitignore no diret√≥rio principal do nosso projeto, com os nomes dos arquivos que queremos ignorar.
No nosso caso, devemos criar um arquivo chamado .gitignore no
diret√≥rio moveis, com o seguinte conte√∫do:
todo.txt
tmp/

27

3.2. Rastreando arquivos

Casa do C√≥digo

Dessa maneira, o arquivo todo.txt e o subdiret√≥rio tmp n√£o ser√£o
mostrados ao executarmos o comando git status:
# On branch master
#
# Initial commit
#
# Changes to be committed:
#
(use "git rm --cached <file>..." to unstage)
#
#
new file:
estilos.css
#
new file:
imagens/logo.png
#
new file:
index.html
#
# Untracked files:
#
(use "git add <file>..." to include in what will be
committed)
#
#
.gitignore

Observe, por√©m, que o arquivo .gitignore apareceu como n√£o rastreado. √â importante que esse arquivo seja rastreado, porque evoluir√° junto com
o reposit√≥rio. Por isso, ao criar o .gitignore, n√£o esque√ßa de adicion√°-lo
√† √°rea de stage com o comando:
$ git add .gitignore

Se quis√©ssemos ignorar todos os arquivos com a extens√£o .log, por
exemplo, colocar√≠amos *.log no .gitignore. Se quis√©ssemos ignorar todos os arquivos .bmp do subdiret√≥rio imagens, dever√≠amos inserir
imagens/*.bmp.

28

Casa do C√≥digo

Cap√≠tulo 3. Trabalhando com reposit√≥rio local

Na pr√°tica, que tipo de arquivos s√£o colocados no .gitignore? Depende da tecnologia utilizada no projeto.
Em projetos Java, arquivos .class, .jar e .war s√£o exemplos
de arquivos que devem ser ignorados. Para projetos Ruby, ignorar√≠amos
arquivos .gem e o diret√≥rio pkg. J√° para projetos Python, arquivos
.egg.
H√° um projeto no GitHub com exemplos de arquivos .gitignore
para diversas linguagens de programa√ß√£o e tecnologias: https://github.
com/github/gitignore

3.3

Gravando arquivos no reposit√≥rio

Os arquivos e altera√ß√µes que foram colocados na √°rea de stage atrav√©s do comando git add ainda n√£o foram gravados no reposit√≥rio. Ao invocarmos
o git status, podemos notar que esses arquivos est√£o prontos para serem
gravados (Changes to be committed):
# On branch master
#
# Initial commit
#
# Changes to be committed:
#
(use "git rm --cached <file>..." to unstage)
#
#
new file:
.gitignore
#
new file:
estilos.css
#
new file:
imagens/logo.png
#
new file:
index.html
#

Para gravar esses arquivos e altera√ß√µes definitivamente no reposit√≥rio, devemos utilizar o comando git commit:
$ git commit -m "Commit inicial"

Observe que passamos uma mensagem que descreve as altera√ß√µes efetuadas, atrav√©s da op√ß√£o -m. Se n√£o pass√°ssemos essa op√ß√£o, seria aberto um
29

3.3. Gravando arquivos no reposit√≥rio

Casa do C√≥digo

editor de texto para informarmos a mensagem.
No nosso caso, utilizamos a mensagem ‚ÄúCommit inicial‚Äù. √â importante
que as mensagens descrevam de maneira sucinta as altera√ß√µes que foram efetuadas.
Depois de executado esse comando, dever√° aparecer algo como:
[master (root-commit) 7777444] Commit inicial
4 files changed, 26 insertions(+)
create mode 100111 .gitignore
create mode 100111 estilos.css
create mode 100111 imagens/logo.png
create mode 100111 index.html

Note que, na primeira linha da sa√≠da apresentada, √© exibido um c√≥digo
logo antes da mensagem ( 7777444, no caso). Esse c√≥digo serve como um
identificador do commit. Na verdade, foram exibidos apenas os primeiros 7
d√≠gitos desse c√≥digo, que cont√©m 40 caracteres ao todo.
Mais especificamente, esse c√≥digo √© um n√∫mero de verifica√ß√£o de integridade de dados (checksum) criado a partir do conte√∫do do arquivo
utilizando a fun√ß√£o de hash SHA-1. Por utilizar SHA-1, √© representado
por um n√∫mero hexadecimal de 40 d√≠gitos.
Se verificarmos agora o estado do reposit√≥rio com o comando git
status, teremos:
# On branch master
nothing to commit, working directory clean

Observe que o n√£o h√° nada mais a ser comitado.
O termo commit √© comum em qualquer sistema controlador de vers√£o
e significa gravar novos arquivos e altera√ß√µes em arquivos existentes em
um reposit√≥rio. Em portugu√™s, os termos comitar ou comitado s√£o bem
corriqueiros, apesar de n√£o existirem nos dicion√°rios.

30

Casa do C√≥digo

Cap√≠tulo 3. Trabalhando com reposit√≥rio local

Rastreando e comitando mudan√ßas de uma s√≥ vez
Percebemos que hav√≠amos esquecido de colocar o t√≠tulo na p√°gina
index.html. Vamos alterar o arquivo:
<!-- in√≠cio do arquivo ... -->
<head>
<!-- tags meta e link ... -->
<title>M√≥veis Ecol√≥gicos</title>
</head>
<!-- restante do arquivo ... -->

Al√©m disso, vamos diminuir o tamanho da p√°gina para ficar melhor
em dispositivos com telas pequenas. Para isso, alteraremos o arquivo
estilos.css:
body {
width: 50%;
margin: auto;
}
/* resto do css */

Se executarmos git status, teremos:
# On branch master
# Changes not staged for commit:
#
(use "git add <file>..." to update what will be committed)
#
(use "git checkout -- <file>..." to discard changes in
working directory)
#
#
modified:
estilos.css
#
modified:
index.html
#
no changes added to commit (use "git add" and/or
"git commit -a")

Note que os arquivos aparecem como modificados, mas a √°rea de stage
ainda n√£o cont√©m as mudan√ßas efetuadas (Changes not staged for commit).
Poder√≠amos efetuar o git add dessas mudan√ßas seguido do git
commit. Por√©m, √© poss√≠vel rastrear as mudan√ßas e comit√°-las de uma vez
com a op√ß√£o -a:
31

3.3. Gravando arquivos no reposit√≥rio

Casa do C√≥digo

$ git commit -a -m "Inserindo titulo e diminuindo tamanho da
pagina"

Teremos como resposta do comando anterior algo como:
[master 2299922] Inserindo titulo e diminuindo tamanho da pagina
2 files changed, 5 insertions(+)

A op√ß√£o -a do comando git commit j√° efetua o rastreamento das mudan√ßas, adicionando-as √† √°rea de stage. Poder√≠amos juntar as op√ß√µes -a e
-m utilizando -am da seguinte maneira: git commit -am "Inserindo
titulo..."

Nesse ponto, a sa√≠da do comando git status indicar√° que n√£o h√° mais
nada a ser comitado:
# On branch master
nothing to commit, working directory clean

Novos arquivos precisam de git add
Nosso cliente pediu que coloc√°ssemos uma mensagem na p√°gina que √©
trocada automaticamente de tempos em tempos.
Para fazer isso, criamos um arquivo chamado principal.js, com o
seguinte conte√∫do:
var banners =
["Os melhores do Brasil!", "Qualidade e pre√ßo baixo!"];
var bannerAtual = 0;
function trocaBanner() {
bannerAtual = (bannerAtual + 1) % 2;
document.querySelector(‚Äôh2#mensagem‚Äô).textContent =
banners[bannerAtual];
}
setInterval(trocaBanner, 2000);

Precisamos tamb√©m adicionar o script anterior √† nossa p√°gina
index.html, al√©m de uma tag h2 que vai conter a mensagem:
32

Casa do C√≥digo

Cap√≠tulo 3. Trabalhando com reposit√≥rio local

<!-- in√≠cio do arquivo ... -->
<head>
<!-- tags meta, link e title ... -->
<script src="principal.js"></script>
</head>
<body>
<!-- tag h1 ... -->
<h2 id="mensagem"></h2>
<!-- restante do arquivo ... -->

Ao executarmos o comando git status, teremos a sa√≠da:
# On branch master
# Changes not staged for commit:
#
(use "git add <file>..." to update what will be committed)
# (use "git checkout -- <file>..." to discard changes in working
directory)
#
#
modified:
index.html
#
# Untracked files:
#
(use "git add <file>..." to include in what will be
committed)
#
#
principal.js
no changes added to commit (use "git add" and/or
"git commit -a")

Observe que √© mostrada a modifica√ß√£o no arquivo index.html e tamb√©m o novo arquivo principal.js.
Vamos executar o comando para rastrear e comitar os arquivos de uma
vez s√≥:
git commit -am "Script de troca de banner"

Na sa√≠da, teremos:
[master 9222999] Script de troca de banner
1 file changed, 2 insertions(+)

33

3.3. Gravando arquivos no reposit√≥rio

Casa do C√≥digo

Qual ser√° a resposta do git status? Ser√°:
# On branch master
# Untracked files:
#
(use "git add <file>..." to include in what will be
committed)
#
#
principal.js
nothing added to commit but untracked files present (use
"git add" to track)

Observe que o git commit com a op√ß√£o -a adicionou no stage apenas as mudan√ßas do arquivo que j√° estava sendo rastreado. O novo arquivo,
principal.js, n√£o passou a ser rastreado.
Sempre que tivermos um arquivo novo, temos que utilizar o comando
git add, para que o Git passe a rastre√°-lo. S√≥ ent√£o poderemos comit√°-lo.
Vamos l√°:
$ git add principal.js

Ap√≥s executarmos o git status, teremos:
# On branch master
# Changes to be committed:
#
(use "git reset HEAD <file>..." to unstage)
#
#
new file:
principal.js
#

Agora podemos comitar o arquivo principal.js:
$ git commit -m "Inserindo arquivo principal.js"

Teremos uma sa√≠da parecida com:
[master 222cccc] Inserindo arquivo principal.js
1 file changed, 10 insertions(+)
create mode 100111 principal.js

Ao executarmos o comando git status, teremos:
34

Casa do C√≥digo

Cap√≠tulo 3. Trabalhando com reposit√≥rio local

# On branch master
nothing to commit, working directory clean

Agora sim! Tanto a altera√ß√£o em index.html como o novo arquivo
principal.js estar√£o comitados no reposit√≥rio.
Ao visualizarmos graficamente as transi√ß√µes entre o diret√≥rio de trabalho,
a √°rea de stage e o reposit√≥rio propriamente dito, ter√≠amos algo como:

Figura 3.2: Gravando arquivos e mudan√ßas com Git

Para saber mais: para que serve a √°rea de stage?
O Git, ao contr√°rio da maioria dos sistemas de controle de vers√£o, possui
uma separa√ß√£o entre rastrear as mudan√ßas, adicionando-as na √°rea de stage
com o comando git add, e gravar as mudan√ßas no reposit√≥rio, com o comando git commit.
Mas ser√° que essa separa√ß√£o √© √∫til? √â sim!
Vamos dizer que estamos desenvolvendo um sistema que tem um m√≥dulo de estoque e um de vendas. Ao desenvolver uma nova funcionalidade,
modificamos quatro arquivos, sendo que dois s√£o de estoque e dois s√£o de
vendas.
Poder√≠amos, primeiramente, gravar as altera√ß√µes feitas nos dois arquivos
de estoque, adicionando apenas esses dois √† stage e comitando-os com uma
mensagem bem descritiva. Depois, far√≠amos o git add e git commit dos
arquivos de vendas, tamb√©m com uma mensagem bem descritiva.
35

3.4. Verificando o hist√≥rico do seu reposit√≥rio

Casa do C√≥digo

Ou seja, essa separa√ß√£o entre rastrear e gravar permite que as mudan√ßas que fizemos no c√≥digo sejam agrupadas de maneira l√≥gica. Dessa forma,
podemos montar commits menores, que far√£o mais sentido posterior ao revisarmos o hist√≥rico do projeto e ajudar√£o ao mesclarmos nossas mudan√ßas
com as dos outros membros do nosso time.

3.4 Verificando o hist√≥rico do seu reposit√≥rio
Para verificar o hist√≥rico das mudan√ßas gravadas no reposit√≥rio, ou seja, os
commits efetuados, devemos utilizar o comando:
$ git log

Ap√≥s executar o comando anterior, teremos a seguinte sa√≠da:
commit 222cccc000000000000000000000000000000000
Author: Fulano da Silva <fulanodasilva.git@gmail.com>
Date:
Wed Apr 30 21:21:31 2014 -0300
Inserindo arquivo principal.js
commit 9222999000000000000000000000000000000000
Author: Fulano da Silva <fulanodasilva.git@gmail.com>
Date:
Wed Apr 30 21:21:33 2014 -0300
Script de troca de banner
commit 2299922000000000000000000000000000000000
Author: Fulano da Silva <fulanodasilva.git@gmail.com>
Date:
Wed Apr 30 14:02:26 2014 -0300
Inserindo titulo e diminuindo tamanho da pagina
commit 7777444000000000000000000000000000000000
Author: Fulano da Silva <fulanodasilva.git@gmail.com>
Date:
Tue Apr 29 21:21:31 2014 -0300
Commit inicial

36

Casa do C√≥digo

Cap√≠tulo 3. Trabalhando com reposit√≥rio local

Observe que foram listadas as mensagens de todos os commits, junto ao
c√≥digo correspondente, autor e data/hora em que foram efetuados.
Se quisermos mostrar apenas os dois √∫ltimos commits devemos utilizar a
op√ß√£o -n:
$ git log -n 2

Ap√≥s executar o comando anterior, teremos a seguinte sa√≠da:
commit 222cccc000000000000000000000000000000000
Author: Fulano da Silva <fulanodasilva.git@gmail.com>
Date:
Wed Apr 30 21:21:31 2014 -0300
Inserindo arquivo principal.js
commit 9222999000000000000000000000000000000000
Author: Fulano da Silva <fulanodasilva.git@gmail.com>
Date:
Wed Apr 30 21:21:33 2014 -0300
Script de troca de banner

Se quisermos um resumo bem conciso dos commits do nosso projeto,
podemos utilizar a op√ß√£o --oneline:
$ git log --oneline

Ser√° apresentado algo semelhante a:
222cccc
9222999
2299922
7777444

Inserindo arquivo principal.js
Script de troca de banner
Inserindo titulo e diminuindo tamanho da pagina
Commit inicial

Podemos mostrar um resumo dos arquivos alterados, com o n√∫mero de
linhas adicionadas e removidas, atrav√©s da op√ß√£o --stat.
$ git log --stat

A sa√≠da ser√° algo como:

37

3.4. Verificando o hist√≥rico do seu reposit√≥rio

Casa do C√≥digo

commit 222cccc000000000000000000000000000000000
Author: Fulano da Silva <fulanodasilva.git@gmail.com>
Date:
Wed Apr 30 21:21:31 2014 -0300
Inserindo arquivo principal.js
principal.js | 10 ++++++++++
1 file changed, 10 insertions(+)
commit 9222999000000000000000000000000000000000
Author: Fulano da Silva <fulanodasilva.git@gmail.com>
Date:
Wed Apr 30 21:21:33 2014 -0300
Script de troca de banner
index.html | 2 ++
1 file changed, 2 insertions(+)
commit 2299922000000000000000000000000000000000
Author: Fulano da Silva <fulanodasilva.git@gmail.com>
Date:
Wed Apr 30 14:02:26 2014 -0300
Inserindo titulo e diminuindo tamanho da pagina
:

Podemos observar que foram mostrados os arquivos modificados e o n√∫mero de inser√ß√µes.
Note tamb√©m que o √∫ltimo caractere foi um dois pontos ( :). Ao apertarmos a tecla Enter, ser√£o mostrados os resultados restantes.
estilos.css | 4 ++++
index.html | 1 +
2 files changed, 5 insertions(+)
commit 7777444000000000000000000000000000000000
Author: Fulano da Silva <fulanodasilva.git@gmail.com>
Date:
Tue Apr 29 21:21:31 2014 -0300
Commit inicial

38

Casa do C√≥digo

.gitignore
estilos.css
imagens/logo.png
index.html
4 files changed,
(END)

Cap√≠tulo 3. Trabalhando com reposit√≥rio local

|
3 +++
|
6 ++++++
| Bin 0 -> 15555 bytes
| 20 ++++++++++++++++++++
29 insertions(+)

Para sairmos do resultados do git log, devemos apertar a tecla q.
Podemos tamb√©m combinar as v√°rias op√ß√µes do comando git log. Por
exemplo, para mostrar um resumo das altera√ß√µes dos √∫ltimos dois commits:
$ git log -n 2 --oneline --stat

Teremos a seguinte sa√≠da:
222cccc Inserindo arquivo principal.js
principal.js | 10 ++++++++++
1 file changed, 10 insertions(+)
9222999 Script de troca de banner
index.html | 2 ++
1 file changed, 2 insertions(+)

Qual a diferen√ßa entre os comandos git status e o git log?
O git status exibe arquivos que est√£o fora da √°rea de stage, prontos para serem adicionados, e arquivos que est√£o dentro da √°rea de stage,
prontos para serem comitados.
J√° o git log exibe o hist√≥rico das mudan√ßas efetivamente gravadas
em um reposit√≥rio. Ou seja, os commits efetuados.

3.5 Verificando mudan√ßas nos arquivos rastreados
Percebemos um bug no nosso c√≥digo: ao abrirmos a p√°gina, n√£o √© mostrado
nenhum banner. Para corrigir, devemos invocar a fun√ß√£o trocaBanner
no evento onload da p√°gina, fazendo a seguinte mudan√ßa no arquivo
index.html:
39

3.5. Verificando mudan√ßas nos arquivos rastreados

Casa do C√≥digo

<!-- in√≠cio do arquivo ... -->
<body onload="trocaBanner();">
<!-- restante do arquivo ... -->

Depois de fazer essa altera√ß√£o, ao invocarmos git status, teremos:
# On branch master
# Changes not staged for commit:
#
(use "git add <file>..." to update what will be committed)
# (use "git checkout -- <file>..." to discard changes in working
directory)
#
#
modified:
index.html
#
no changes added to commit (use "git add" and/or
"git commit -a")

Tudo conforme o esperado. √â informado que o arquivo index.html
sofreu uma modifica√ß√£o.

Verificando mudan√ßas ainda n√£o rastreadas
Se quisermos revisar a modifica√ß√£o efetuada, verificando as diferen√ßas entre o arquivo alterado e o que foi comitado anteriormente, podemos usar o
comando:
$ git diff

Ser√° mostrado algo como:
diff --git a/index.html b/index.html
index 7771111..0000000 100111
--- a/index.html
+++ b/index.html
@@ -8,7 +8,7 @@
<title>M√≥veis Ecol√≥gicos</title>
<script src="principal.js"></script>
</head>
<body>
+
<body onload="trocaBanner();">

40

Casa do C√≥digo

Cap√≠tulo 3. Trabalhando com reposit√≥rio local

<h1>M√≥veis Ecol√≥gicos S. A.</h1>
<h2 id="mensagem"></h2>

Observe que foi mostrada exatamente a mudan√ßa que fizemos anteriormente: a troca de <body> por <body onload="trocaBanner();">.
Quando tivermos altera√ß√µes ainda n√£o rastreadas em mais de um arquivo
e quisermos verificar o que mudamos em um arquivo espec√≠fico, basta passarmos o nome desse arquivo como par√¢metro. Por exemplo, para verificarmos as mudan√ßas apenas no arquivo index.html, far√≠amos: git diff
index.html.
O git diff n√£o poder√° ser utilizado para arquivos novos, que ainda
n√£o est√£o sendo rastreados pelo Git (ou seja, que ainda n√£o tiveram o
primeiro git add executado).

Verificando mudan√ßas rastreadas
Vamos adicionar as mudan√ßas que fizemos √† √°rea de stage com o comando
git add index.html.
Se executarmos git diff novamente, n√£o ser√° mostrada nenhuma
sa√≠da. O comando git diff, quando usado sem par√¢metros, mostra a diferen√ßa entre os arquivos no diret√≥rio de trabalho e a √°rea de stage. Portanto,
serve apenas para exibir as mudan√ßas ainda n√£o rastreadas.
√â poss√≠vel mostrar as diferen√ßas entre os arquivos na √°rea de stage e a
√∫ltima vers√£o que foi comitada utilizando a op√ß√£o --staged:
$ git diff --staged

Ser√° exibida uma sa√≠da exatamente igual √† anterior, j√° que a altera√ß√£o apenas passou para a √°rea de stage mas continua a mesma:
diff --git a/index.html b/index.html
index 7771111..0000000 100111
--- a/index.html
+++ b/index.html
@@ -8,7 +8,7 @@

41

Casa do C√≥digo

3.5. Verificando mudan√ßas nos arquivos rastreados

<title>M√≥veis Ecol√≥gicos</title>
<script src="principal.js"></script>
</head>
<body>
<body onload="trocaBanner();">
<h1>M√≥veis Ecol√≥gicos S. A.</h1>
<h2 id="mensagem"></h2>

+

Antes da vers√£o 1.6.1 do Git, s√≥ havia a op√ß√£o --cached, que tem o
mesmo efeito da op√ß√£o --staged.

Verificando mudan√ßas rastreadas e n√£o rastreadas ao mesmo
tempo
Vamos diminuir o tempo de troca do banner para um segundo alterando
o arquivo principal.js:
//inicio do arquivo...
setInterval(trocaBanner, 1000);

Nesse ponto, temos duas altera√ß√µes.

Uma delas foi no arquivo

index.html que j√° est√° na √°rea de stage. Tamb√©m temos uma altera√ß√£o no
arquivo principal.js ainda n√£o rastreada. Isso pode ser verificado com
o comando git status:
# On branch master
# Changes to be committed:
#
(use "git reset HEAD <file>..." to unstage)
#
#
modified:
index.html
#
# Changes not staged for commit:
#
(use "git add <file>..." to update what will be committed)
# (use "git checkout -- <file>..." to discard changes in working
directory)
#
#
modified:
principal.js
#

42

Casa do C√≥digo

Cap√≠tulo 3. Trabalhando com reposit√≥rio local

Se executarmos o comando git diff, veremos apenas a altera√ß√£o no
arquivo principal.js:
diff --git a/principal.js b/principal.js
index 4111114..0000000 100111
--- a/principal.js
+++ b/principal.js
@@ -6,5 +6,5 @@ function trocaBanner() {
document.querySelector(‚Äôh2#mensagem‚Äô).textContent =
banners[bannerAtual];
}
-setInterval(trocaBanner, 2000);
+setInterval(trocaBanner, 1000);

J√° ao executarmos o comando git diff --staged, veremos apenas a
altera√ß√£o no arquivo index.html, que j√° verificamos anteriormente.
Ser√° que √© poss√≠vel exibir tanto as altera√ß√µes fora da √°rea de stage como as
de dentro?
Sim! Para isso, precisamos descobrir o c√≥digo do √∫ltimo commit. Podemos fazer isso com o comando git log -n 1 --oneline. Teremos a
sa√≠da:
222cccc Inserindo arquivo principal.js

Com o c√≥digo do √∫ltimo commit em m√£os, agora podemos mostrar as
altera√ß√µes dentro e fora da stage utilizando o comando:
$ git diff 222cccc

Ser√£o exibidas ambas as altera√ß√µes:
diff --git a/index.html b/index.html
index 7771111..0000000 100111
--- a/index.html
+++ b/index.html
@@ -8,7 +8,7 @@
<title>M√≥veis Ecol√≥gicos</title>
<script src="principal.js"></script>

43

3.5. Verificando mudan√ßas nos arquivos rastreados

Casa do C√≥digo

</head>
<body>
+
<body onload="trocaBanner();">
<h1>M√≥veis Ecol√≥gicos S. A.</h1>
<h2 id="mensagem"></h2>
diff --git a/principal.js b/principal.js
index 9999988..0000000 100111
--- a/principal.js
+++ b/principal.js
@@ -6,5 +6,5 @@ function trocaBanner() {
document.querySelector(‚Äôh2#mensagem‚Äô).textContent =
banners[bannerAtual];
}
-setInterval(trocaBanner, 2000);
+setInterval(trocaBanner, 1000);
:

Como o resultado √© extenso, ser√° mostrado o caractere dois pontos ( :).
Para irmos para os pr√≥ximos resultados devemos pressionar a tecla Enter.
Para sairmos, devemos apertar a tecla q.

No nosso caso, ter√≠amos a mesma sa√≠da anterior, que mostra as altera√ß√µes dentro e fora do stage, utilizando o comando git diff HEAD.
Isso acontece porque, no nosso caso, HEAD est√° apontado para o √∫ltimo commit efetuado.
Por√©m, n√£o √© sempre assim, j√° que o HEAD pode apontar para commits anteriores.

Verificando mudan√ßas j√° comitadas
Vamos comitar nossas modifica√ß√µes em index.html com o comando git commit -m "Banner ao abrir pagina". Ser√° exibido
algo como:
[master 4000004] Banner ao abrir a pagina
1 file changed, 1 insertion(+), 1 deletion(-)

44

Casa do C√≥digo

Cap√≠tulo 3. Trabalhando com reposit√≥rio local

Tamb√©m precisamos comitar as altera√ß√µes em principal.js, que
ainda n√£o est√° na √°rea de stage. Para isso, utilizaremos a op√ß√£o -a: git
commit -am "Diminuindo intervalo de troca de banner". Teremos na sa√≠da algo como:
[master 8877887] Diminuindo intervalo de troca de banner
1 file changed, 1 insertion(+), 1 deletion(-)

Ent√£o, vamos mostrar os tr√™s √∫ltimos commits de maneira concisa atrav√©s
do comando git log -n 3 --oneline. A sa√≠da ser√° semelhante a:
8877887 Diminuindo intervalo de troca de banner
4000004 Banner ao abrir a pagina
222cccc Inserindo arquivo principal.js

Agora n√£o temos nenhuma altera√ß√£o n√£o comitada. Ufa!
Podemos usar o comando git diff para verificar as diferen√ßas entre
dois commits espec√≠ficos. Para comparar o que foi alterado no nosso √∫ltimo
commit em rela√ß√£o aos dois anteriores, devemos utilizar o git diff passando os c√≥digos desses commits:
$ git diff 222cccc..8877887

Observe que passamos o c√≥digo dos commits separados por ponto-ponto
( ..). Podemos ler o comado anterior como: ‚Äúmostre as mudan√ßas efetuadas
a partir do commit 842d2cf at√© o commit 8aa07bd‚Äù.
A resposta desse comando mostrar√° as altera√ß√µes que acabamos de gravar
no reposit√≥rio:
diff --git a/index.html b/index.html
index 7771111..0000000 100111
--- a/index.html
+++ b/index.html
@@ -8,7 +8,7 @@
<title>M√≥veis Ecol√≥gicos</title>
<script src="principal.js"></script>
</head>
<body>
+
<body onload="trocaBanner();">

45

3.5. Verificando mudan√ßas nos arquivos rastreados

Casa do C√≥digo

<h1>M√≥veis Ecol√≥gicos S. A.</h1>
<h2 id="mensagem"></h2>
diff --git a/principal.js b/principal.js
index 4111114..0000000 100111
--- a/principal.js
+++ b/principal.js
@@ -6,5 +6,5 @@ function trocaBanner() {
document.querySelector(‚Äôh2#mensagem‚Äô).textContent =
banners[bannerAtual];
}
-setInterval(trocaBanner, 2000);
+setInterval(trocaBanner, 1000);
:

Poder√≠amos obter a mesma sa√≠da atrav√©s do comando:
$ git diff 8877887~2

O comando anterior exibe as mudan√ßas nos arquivos do commit de c√≥digo 8877887 em rela√ß√£o aos dois commits feitos imediatamente antes. O
n√∫mero depois do ~ indica quantos commits anteriores devem ser considerados na compara√ß√£o. No nosso caso, foram dois.
Apesar de apresentarem a mesma sa√≠da no nosso caso, os par√¢metros
222cccc..8877887 e 8877887 ~ 2 n√£o s√£o exatamente equivalentes.
Se houvesse alguma modifica√ß√£o ainda n√£o comitada, fora ou dentro da
√°rea de stage, as linhas alteradas tamb√©m seriam mostradas na resposta do
comando git diff 8877887 ~ 2.
J√° o comando git diff 222cccc..8877887 n√£o exibe modifica√ß√µes
ainda n√£o comitadas, mas apenas as mudan√ßas que aconteceram entre os dois
commits especificados.
O comando git status lista os arquivos modificados e o conte√∫do
da √°rea de stage. J√° o comando git diff mostra detalhadamente quais
foram essas modifica√ß√µes, al√©m de permitir verificar mudan√ßas entre dois
commits.

46

Casa do C√≥digo

Cap√≠tulo 3. Trabalhando com reposit√≥rio local

3.6 Removendo arquivos do reposit√≥rio
Vamos dizer que criamos um arquivo produtos.html com o seguinte conte√∫do:
<html>
<body>
<ul>
<li>M√≥veis de garrafas PET</li>
<li>M√≥veis de latinhas de alum√≠nio</li>
<li>M√≥veis de papel√£o</li>
</ul>
</body>
</html>

Ent√£o, informamos ao Git que queremos rastre√°-lo, atrav√©s do comando
git add produtos.html. Depois, gravamos o conte√∫do do arquivo no
reposit√≥rio com o comando git commit -m "P√°gina de produtos".
Mas acabamos percebendo que replicamos o conte√∫do do arquivo index.html e, por isso, gostar√≠amos de remover o arquivo
produtos.html.
Por√©m, n√£o basta deletarmos o produtos.html. Precisamos delet√°lo e adicionar a dele√ß√£o na stage, para s√≥ ent√£o efetuarmos um commit no
reposit√≥rio.
A remo√ß√£o do arquivo e adi√ß√£o na stage podem ser realizadas de uma vez
s√≥ atrav√©s do comando:
$ git rm produtos.html

Depois do comando anterior, o arquivo produtos.html n√£o existir√°
mais. Se executarmos git status, teremos:
# On branch master
# Changes to be committed:
#
(use "git reset HEAD <file>..." to unstage)
#
#
deleted:
produtos.html
#

47

3.6. Removendo arquivos do reposit√≥rio

Casa do C√≥digo

Observe que a dele√ß√£o de produtos.html j√° est√° na √°rea de stage,
pronta para ser comitada com o comando git commit -m "Removendo
p√°gina de produtos".
Se j√° tiv√©ssemos removido o arquivo produtos.html, ao executarmos
git rm produtos.html, a dele√ß√£o do arquivo seria colocada na √°rea de
stage.
Uma outra maneira de adicionar a dele√ß√£o de um arquivo √† √°rea de stage
seria executar o comando git add. Por√©m, esse comando n√£o permite o
uso em arquivos removidos, a n√£o ser que seja utilizada a op√ß√£o --all.
Adicionando a remo√ß√£o de arquivos ao nosso gr√°fico, ter√≠amos:

Figura 3.3: Removendo arquivos com Git

48

Casa do C√≥digo

Cap√≠tulo 3. Trabalhando com reposit√≥rio local

Um detalhe importante √© saber que, apesar de o arquivo ter sido removido, seu conte√∫do fica gravado no hist√≥rico do reposit√≥rio. Dessa
maneira, √© poss√≠vel obtermos qualquer arquivo que j√° existiu em nosso
reposit√≥rio.
Por√©m, se por descuido comitarmos algum arquivo grande e depois
delet√°-lo, nosso reposit√≥rio n√£o diminuir√° de tamanho, j√° que o hist√≥rico
ser√° mantido. Mais adiante, veremos como limpar nosso reposit√≥rio, expurgando arquivos grandes, utilizando ferramentas apropriadas.

3.7

Renomeando e movendo arquivos

Renomeando arquivos
Para manter o padr√£o de nomenclatura, resolvemos modificar o nome do arquivo estilos.css para principal.css.
Para fazer isso, ter√≠amos que criar o novo arquivo, copiar seu conte√∫do,
remover o arquivo antigo, adicionando tanto o novo arquivo como a dele√ß√£o
do arquivo antigo na √°rea de stage.
Bastante trabalho, n√£o? Ainda bem que esse trabalho todo pode ser poupado com o comando:
$ git mv estilos.css principal.css

Se executarmos o comando git status, teremos:
# On branch master
# Changes to be committed:
#
(use "git reset HEAD <file>..." to unstage)
#
#
renamed:
estilos.css -> principal.css
#

Podemos observar que o arquivo aparece como renomeado na √°rea de
stage e pronto para ser comitado. E, claro, se observarmos no diret√≥rio do
nosso reposit√≥rio, o arquivo foi realmente renomeado.
49

3.7. Renomeando e movendo arquivos

Casa do C√≥digo

√â interessante saber que, se tiv√©ssemos renomeado o arquivo da maneira
mais trabalhosa, o Git iria detectar o nosso objetivo, depois que tiv√©ssemos
efetuados todos os comandos necess√°rios. Isso acontece porque o Git rastreia
o conte√∫do dos arquivos, n√£o apenas o nome.
Antes de continuarmos, precisamos atualizar o nome do arquivo CSS em
index.html:
<!-- in√≠cio do arquivo ... -->
<head>
<!-- tags meta ... -->
<link rel="stylesheet" href="principal.css">
<!-- tags title e script ... -->
</head>
<!-- restante do arquivo ... -->

Feitas as altera√ß√µes, podemos grav√°-las no reposit√≥rio com o comando
git commit -am "Renomeando CSS". Na sa√≠da, deve aparecer:
[master 5777775] Renomeando CSS
2 files changed, 1 insertion(+), 1 deletion(-)
rename estilos.css => principal.css (100%)

Pronto! Arquivo renomeado!

Movendo arquivos
E se quisermos mover o arquivo principal.js para um subdiret√≥rio
chamado js?
Primeiramente, devemos criar o diret√≥rio js.
Depois, dever√≠amos criar um arquivo principal.js dentro desse novo
diret√≥rio, copiar os conte√∫dos do arquivo anterior e adicionar o novo diret√≥rio √† √°rea de stage. Feito isso, precisar√≠amos remover o arquivo atual, adicionando a remo√ß√£o √† stage. S√≥ ent√£o poder√≠amos comitar as altera√ß√µes.
Todo esse trabalho tamb√©m pode ser poupado pelo comando git mv:
$ git mv principal.js js/principal.js

Aten√ß√£o: √© importante que o diret√≥rio js j√° tenha sido criado!
Se executarmos o comando git status, teremos:
50

Casa do C√≥digo

Cap√≠tulo 3. Trabalhando com reposit√≥rio local

# On branch master
# Changes to be committed:
#
(use "git reset HEAD <file>..." to unstage)
#
#
renamed:
principal.js -> js/principal.js
#

Note que o arquivo principal.js foi descrito como renomeado para o
novo arquivo, que est√° dentro do subdiret√≥rio js. Para o Git, n√£o h√° diferen√ßa
entre um arquivo movido ou renomeado. No fim das contas, aquele conte√∫do
(o que √© efetivamente rastreado) mudou de local.
Vamos atualizar o arquivo index.html para apontar para a localiza√ß√£o
correta do arquivo principal.js:
<!-- in√≠cio do arquivo ... -->
<head>
<!-- tags meta, link e title ... -->
<script src="js/principal.js"></script>
</head>
<!-- restante do arquivo ... -->

Ent√£o, comitar as altera√ß√µes com

git commit -am "Movendo

principal.js". Na sa√≠da, deve aparecer:
[master 7733388] Movendo principal.js
2 files changed, 1 insertion(+), 1 deletion(-)
rename principal.js => js/principal.js (100%)

Pronto! Arquivo movido!
Incluindo a movimenta√ß√£o de arquivos na nossa visualiza√ß√£o, ficar√≠amos
com:

51

3.8. Desfazendo mudan√ßas

Casa do C√≥digo

Figura 3.4: Renomeando e movendo arquivos com Git

3.8

Desfazendo mudan√ßas

Desfazendo mudan√ßas n√£o rastreadas
Vamos dizer que o dono da empresa M√≥veis S. A. ligou de madrugada depois
de tomar umas e outras, pedindo para colocarmos na p√°gina principal, um
texto um tanto peculiar.
Para atend√™-lo, editamos o arquivo index.html, colocando o seguinte
conte√∫do no fim do arquivo:
<!-- inicio do arquivo -->
<p>M√≥veis baratos pra c**!****
!<
!/p>
</body>
</html>

Fizemos a altera√ß√£o sem muita convic√ß√£o. Por isso, n√£o a adicionamos na
√°rea de stage. A resposta de um git status seria:
52

Casa do C√≥digo

Cap√≠tulo 3. Trabalhando com reposit√≥rio local

# On branch master
# Changes not staged for commit:
#
(use "git add <file>..." to update what will be committed)
# (use "git checkout -- <file>..." to discard changes in working
directory)
#
#
modified:
index.html
#
no changes added to commit (use "git add" and/or
"git commit -a")

Logo de manh√£, o dono da empresa liga arrependido, pedindo para desfazermos as altera√ß√µes.
Como podemos fazer de maneira f√°cil?
Devemos executar o seguinte comando:
$ git checkout -- index.html

O comando git checkout desfaz as altera√ß√µes ainda n√£o rastreadas,
ou seja, que ainda n√£o est√£o na √°rea de stage, voltando ao conte√∫do anterior
do arquivo.
Ap√≥s um git status ter√≠amos:
# On branch master
nothing to commit, working directory clean

Ao verificarmos o conte√∫do do arquivo index.html, podemos constatar que a nossa mudan√ßa foi desfeita e o arquivo ficou com o conte√∫do original, conforme o √∫ltimo commit.

Caso haja alguma mudan√ßa j√° rastreada no arquivo, dentro da √°rea de
stage, ao executarmos o comando git checkout, apenas as altera√ß√µes
indesejadas, fora da stage, ser√£o desfeitas. As mudan√ßas que j√° estavam
na stage permanecer√£o. Ser√£o desfeitas apenas as altera√ß√µes, que ainda
n√£o tinham sido rastreadas.

53

Casa do C√≥digo

3.8. Desfazendo mudan√ßas

E se apagarmos algum arquivo sem querer? Medo! Desespero!
Vamos dizer que apagamos o arquivo index.html.
Ao executarmos o comando git status, ter√≠amos:
# On branch master
# Changes not staged for commit:
#
(use "git add/rm <file>..."to update what will be committed)
# (use "git checkout -- <file>..." to discard changes in working
directory)
#
#
deleted:
index.html
#
no changes added to commit (use "git add" and/or
"git commit -a")

Quem poder√° nos ajudar? O Git, √© claro.
Podemos utilizar o comando git checkout para recuperar arquivos
removidos acidentalmente:
$ git checkout -- index.html

Pronto! Arquivo recuperado!

Desfazendo mudan√ßas j√° rastreadas
E se j√° tivermos rastreado uma mudan√ßa indesejada no arquivo? Como
voltar atr√°s?
Vamos dizer que fizemos a seguinte modifica√ß√£o no fim do arquivo
index.html:
<!-- inicio do arquivo -->
<p>M√≥veis baratos pra
</body>
</html>

!

</p>
!!

Logo depois, colocamos a mudan√ßa na √°rea de stage com o comando git
add index.html. Ao executarmos o git status, ter√≠amos:

54

Casa do C√≥digo

Cap√≠tulo 3. Trabalhando com reposit√≥rio local

# On branch master
# Changes to be committed:
#
(use "git reset HEAD <file>..." to unstage)
#
#
modified:
index.html
#

Se quisermos apenas remover da √°rea de stage a mudan√ßa efetuada no arquivo index.html, preservando o arquivo modificado, devemos executar:
$ git reset -- index.html

Quando utilizado dessa maneira, apenas informando um arquivo que tem
mudan√ßas na √°rea de stage, o comando git reset retira o arquivo da stage
mas preserva tudo o que foi modificado nesse arquivo.
Ao verificarmos o arquivo index.html, veremos que as altera√ß√µes que
fizemos anteriormente estar√£o intocadas.
Depois de executarmos o comando git status, veremos que as mudan√ßas aparecem fora da √°rea de stage (Changes not staged for commit):
# On branch master
# Changes not staged for commit:
#
(use "git add <file>..." to update what will be committed)
# (use "git checkout -- <file>..." to discard changes in working
directory)
#
#
modified:
index.html
#
no changes added to commit (use "git add" and/or
"git commit -a")

Se invocarmos o comando git reset sem nenhum par√¢metro, ser√£o retirados todos os arquivos da √°rea de stage. As altera√ß√µes efetuadas
nesses arquivos ser√£o preservadas.
No caso de querermos descartar todas as mudan√ßas nos arquivos ao invocarmos git reset, devemos utilizar a op√ß√£o --hard.
55

Casa do C√≥digo

3.8. Desfazendo mudan√ßas

H√° um detalhe importante: a op√ß√£o --hard retira todos os arquivos da
√°rea de stage e desfaz todas as altera√ß√µes nesses arquivos. No fim das contas,
o reposit√≥rio fica exatamente no estado que estava no √∫ltimo commit.
Para testarmos, vamos colocar as mudan√ßas no arquivo index.html
novamente na √°rea de stage executando git add index.html.
Ent√£o, vamos executar o comando:
$ git reset --hard

Deve aparecer algo como:
HEAD is now at 7733388 Movendo principal.js

Todos os arquivos foram retirados da √°rea de stage e todas as altera√ß√µes
nesses arquivos foram desfeitas. Podemos confirmar isso executando o comando git status novamente:
# On branch master
nothing to commit, working directory clean

Ou seja, depois do git reset --hard, o reposit√≥rio voltou a ficar exatamente como estava no √∫ltimo commit. Nenhum arquivo estar√° modificado
e a √°rea de stage estar√° vazia.

Desfazendo mudan√ßas j√° comitadas
Agora, e se j√° tivermos comitado algumas modifica√ß√µes e quisermos voltar atr√°s?
Por exemplo, se tivermos feito as seguintes mudan√ßas no arquivo
index.html:
<!-- inicio do arquivo -->
<p>M√≥veis baratos pra
</body>
</html>

!

</p>
!!

Depois, comitamos as altera√ß√µes:
$ git commit -am "Adicionando texto peculiar"

56

Casa do C√≥digo

Cap√≠tulo 3. Trabalhando com reposit√≥rio local

Na sa√≠da, ter√≠amos algo como:
[master 6111116] Adicionando texto peculiar
1 file changed, 1 insertion(+)

Se quisermos voltar atr√°s, desfazendo as altera√ß√µes no reposit√≥rio, podemos utilizar o comando:
$ git revert --no-edit 6111116

Nesse comando, o c√≥digo 6111116 representa o √∫ltimo commit efetuado. Se omitirmos a op√ß√£o --no-edit, ser√° aberto um editor de texto para
editarmos a mensagem do novo commit.

Em vez de passar o c√≥digo do √∫ltimo commit como par√¢metro para o
git revert, poder√≠amos ter utilizado HEAD que, no nosso caso, aponta
para o √∫ltimo commit.
Ap√≥s executar o git revert, ter√≠amos como resposta algo parecido
com:
[master 2121212] Revert "Adicionando texto peculiar"
1 file changed, 1 deletion(-)

Ao verificarmos o arquivo index.html veremos que as altera√ß√µes do
√∫ltimo commit foram desfeitas, retornando √† vers√£o anterior.
Se observarmos novamente o hist√≥rico de commits do nosso reposit√≥rio,
com o comando git log -n 2 --oneline, teremos:
2121212 Revert "Adicionando texto peculiar"
6111116 Adicionando texto peculiar

Note que o comando git revert efetuou um novo commit com a vers√£o anterior dos arquivos. Foi utilizada a mensagem Revert seguida da mensagem do commit anterior (no exemplo, Revert ‚ÄúAdicionando texto peculiar‚Äù).

57

3.8. Desfazendo mudan√ßas

Casa do C√≥digo

No caso de passarmos um c√≥digo de commit antigo, apenas as altera√ß√µes feitas naquele commit ser√£o desfeitas. Isso √© algo bastante poderoso!
Imagine que voc√™ descubra que um bug veio de uma altera√ß√£o de determinado commit em um conjunto de arquivos. Apenas com um git
revert √© poss√≠vel desfazer as altera√ß√µes que inseriram o bug.
Por isso, vale reiterar que commits pequenos e bem montados s√£o
importantes para podermos utilizar o real poder do Git.
Uma outra forma de desfazer altera√ß√µes j√° comitadas √© utilizando o comando git reset seguido da op√ß√£o --hard e de um c√≥digo de commit.
Se quisermos voltar ao commit anterior √†s altera√ß√µes peculiares solicitadas pelo nosso cliente, devemos executar:
$ git reset --hard 7733388

Ter√≠amos como resposta algo similar a:
HEAD is now at 7733388 Movendo principal.js

Se observamos os arquivos, as √∫ltimas altera√ß√µes foram desfeitas.
No hist√≥rico do reposit√≥rio, exibido ao executarmos git log
--oneline, os commits descartados n√£o aparecem:
7733388
5777775
3234100
65727bb
8877887
4000004
222cccc
9222999
2299922
7777444

Movendo principal.js
Renomeando CSS
Removendo p√°gina de produtos
P√°gina de produtos
Diminuindo intervalo de troca de banner
Banner ao abrir a pagina
Inserindo arquivo principal.js
Script de troca de banner
Inserindo titulo e diminuindo tamanho da pagina
Commit inicial

Ao utilizarmos o comando git reset da maneira anterior, com a op√ß√£o
--hard e um c√≥digo de commit, o hist√≥rico do reposit√≥rio √© reescrito.
58

Casa do C√≥digo

Cap√≠tulo 3. Trabalhando com reposit√≥rio local

Por√©m, √© importante mantermos todas as altera√ß√µes gravadas no reposit√≥rio, mesmo que indesejadas. Afinal de contas, estamos utilizando um sistema
de controle de vers√µes justamente para ter um hist√≥rico fiel da evolu√ß√£o do
c√≥digo de nossos projetos.
Por isso, nas raras ocasi√µes em que √© necess√°rio desfazer commits, recomendamos que seja utilizado o comando git revert.
Atualizando nossa visualiza√ß√£o gr√°fica do que aprendemos, agora com
comandos para desfazer modifica√ß√µes, temos:

Figura 3.5: Desfazendo mudan√ßas com Git

59

Cap√≠tulo 4

Trabalhando com reposit√≥rio
remoto
Nosso projeto j√° possui v√°rios arquivos, e tamb√©m alguns commits que fizemos para guardar o hist√≥rico das modifica√ß√µes realizadas. Entretanto, todos os commits est√£o registrados apenas localmente, ou seja, unicamente no
nosso computador.
Se algum dia nosso computador apresentar algum problema t√©cnico, e
deixar de funcionar, ou at√© mesmo se ele for roubado, ter√≠amos um s√©rio problema, pois junto com ele perder√≠amos tamb√©m nosso reposit√≥rio e o projeto.
Podemos adotar uma estrat√©gia de realizar backups semanalmente do
nosso reposit√≥rio, ou at√© mesmo diariamente, para que assim sempre tenhamos uma c√≥pia de seguran√ßa.
Entretanto, essa estrat√©gia de realiza√ß√£o de backups √© desaconselhada por

4.1. Reposit√≥rio remoto

Casa do C√≥digo

ser trabalhosa e sujeita a falhas, j√° que podemos nos esquecer de realizar o
backup em algum dia.
Al√©m disso, manter o reposit√≥rio apenas localmente nos traz outra quest√£o: como fazer para trabalhar em equipe, com v√°rios desenvolvedores alterando os arquivos do projeto e registrando essas altera√ß√µes com commits?
Certamente ficar compactando e enviando o reposit√≥rio para os outros
membros da equipe, a cada novo commit, n√£o parece ser uma ideia muito
boa.

4.1

Reposit√≥rio remoto

Para evitar os problemas citados anteriormente devemos trabalhar com um
reposit√≥rio remoto, que nada mais √© do que um reposit√≥rio Git criado em
outro computador, chamado de servidor.
Se os desenvolvedores da equipe trabalham na mesma empresa, todos eles
v√£o estar conectados pela rede. Sendo assim, para criarmos um reposit√≥rio
remoto, devemos primeiramente utilizar algum computador da empresa que
esteja conectado na rede, e criar o reposit√≥rio Git do projeto neste computador, que passar√° a ser o servidor central do projeto.

Criando um reposit√≥rio remoto
A cria√ß√£o do reposit√≥rio remoto √© feita com o comando git init, da
mesma maneira que fizemos para criar o reposit√≥rio local, entretanto devemos passar o par√¢metro --bare ao comando:
$ git init --bare moveis-ecologicos.git

Ao executar o comando, ser√° apresentada uma mensagem como:
Initialized empty Git repository
in /opt/repositorios/moveis-ecologicos.git/

O par√¢metro --bare serve para que o Git n√£o crie um working tree (diret√≥rio de trabalho), impedindo que commits sejam efetuados diretamente no
servidor. No nosso caso faz sentido, j√° que os commits ser√£o realizados pelos
62

Casa do C√≥digo

Cap√≠tulo 4. Trabalhando com reposit√≥rio remoto

desenvolvedores, localmente, em seus computadores, e depois esses commits
ser√£o enviados e armazenados no reposit√≥rio remoto, localizado no servidor.
Ao
executar
o
comando
git init --bare
moveis-ecologicos.git, o Git criar√° um novo diret√≥rio chamado
moveis-ecologicos.git com a seguinte estrutura:

Figura 4.1: Estrutura de diret√≥rios do reposit√≥rio Git

Lembre-se de nunca mexer nesses arquivos e diret√≥rios, pois eles representam o reposit√≥rio Git e devem ser manipulados apenas pelo Git.

4.2 Adicionando o reposit√≥rio remoto
Agora que o reposit√≥rio remoto j√° foi criado no servidor, √© poss√≠vel enviar os
commits efetuados no nosso reposit√≥rio local para o reposit√≥rio remoto. Mas
antes disso precisamos, de alguma maneira, indicar ao Git onde est√° localizado o reposit√≥rio remoto.
Para ensinar ao Git onde se encontra o nosso reposit√≥rio remoto, devemos
utilizar o comando git remote add, no qual informamos o endere√ßo do
reposit√≥rio remoto.
Supondo que o nosso servidor esteja na rede com o endere√ßo IP
192.168.1.1 , e o reposit√≥rio remoto do nosso projeto tenha sido criado
no diret√≥rio /opt/repositorios/moveis-ecologicos.git, para adicionarmos o reposit√≥rio remoto devemos executar o comando git remote
add da seguinte maneira:
63

4.2. Adicionando o reposit√≥rio remoto

Casa do C√≥digo

$ git remote add servidor
file://192.168.1.1/opt/repositorios/moveis-ecologicos.git

Ao executar o comando git remote add devemos informar o name
(nome) do reposit√≥rio remoto e sua url (endere√ßo).
No exemplo anterior, o name do reposit√≥rio adicionado foi servidor e a
url foi file://192.168.10.1/opt/repositorios/moveis-ecologicos.git.
√â poss√≠vel adicionar mais de um reposit√≥rio remoto, desde que cada um
tenha seu name distinto. Isto pode ser √∫til se precisarmos enviar os commits
para mais de um servidor.

Listando os reposit√≥rios remotos
Para listar os reposit√≥rios remotos que foram adicionados devemos utilizar o comando git remote:
$ git remote
servidor

Mas repare que √© exibido apenas o name dos reposit√≥rios remotos. Para
que tamb√©m seja exibida a url devemos adicionar o par√¢metro -v ao comando:
$ git remote -v
servidor file://192.168.1.1/opt/repositorios/
moveis-ecologicos.git (fetch)
servidor file://192.168.1.1/opt/repositorios/
moveis-ecologicos.git (push)

Observe que o reposit√≥rio remoto foi listado duas vezes. Isso acontece
pois o Git permite que tenhamos duas URLs distintas para o mesmo reposit√≥rio remoto, sendo uma para leitura (fetch) e outra para escrita (push). Isto
pode ser √∫til se precisarmos utilizar protocolos distintos para leitura e escrita.

Alterando e removendo os reposit√≥rios remotos
√â poss√≠vel alterar o name de um reposit√≥rio remoto utilizando o comando
git remote rename:
64

Casa do C√≥digo

Cap√≠tulo 4. Trabalhando com reposit√≥rio remoto

$ git remote rename servidor outronome
$ git remote
outronome

O que aconteceria se algu√©m alterasse o endere√ßo IP do servidor de
192.168.1.1
para 192.168.1.2
? Ter√≠amos um problema, pois
nosso reposit√≥rio remoto estaria apontando para o endere√ßo antigo. Devemos nesse caso alterar a url do reposit√≥rio remoto, e isto √© feito com outro
comando, o git remote set-url, passando como par√¢metro o name do
reposit√≥rio remoto e a nova url:
$ git remote -v
servidor file://192.168.1.1/opt/repositorios/
moveis-ecologicos.git (fetch)
servidor file://192.168.1.1/opt/repositorios/
moveis-ecologicos.git (push)
$ git remote set-url servidor
file://192.168.1.2/opt/repositorios/moveis-ecologicos.git
$ git remote -v
servidor file://192.168.1.2/opt/repositorios/
moveis-ecologicos.git (fetch)
servidor file://192.168.1.2/opt/repositorios/
moveis-ecologicos.git (push)

4.3

Enviando commits para o reposit√≥rio remoto

Agora que j√° adicionamos o reposit√≥rio remoto, podemos, enfim, enviar os
commits para o servidor.
Para enviar os commits locais, que ainda n√£o existem no servidor, devemos utilizar o comando git push, informando o name do reposit√≥rio
remoto, no nosso caso servidor, seguido de master:
$ git push servidor master

Ser√° exibida uma mensagem como:
65

4.4. Clonando o reposit√≥rio remoto

Casa do C√≥digo

Counting objects: 3, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (2/2), 227 bytes | 0 bytes/s, done.
Total 2 (delta 1), reused 0 (delta 0)
To file://192.168.1.1/opt/repositorios/moveis-ecologicos.git/
3333355..0000000 master -> master

Pronto! Agora os commits j√° foram enviados para o servidor.

A palavra master que utilizamos no comando anterior √© o nome
da branch principal do nosso reposit√≥rio. Estudaremos branches com
profundidade mais adiante.

4.4

Clonando o reposit√≥rio remoto

Nosso projeto continua a crescer e n√£o param de chegar mais pedidos de funcionalidades. Tivemos que contratar mais um desenvolvedor para a equipe,
e ele j√° est√° pronto para come√ßar a desenvolver as novas funcionalidades do
sistema, mas para isso vai precisar, primeiramente, obter uma c√≥pia do reposit√≥rio com todos os arquivos e commits.
Para obtermos uma c√≥pia de um reposit√≥rio Git, devemos utilizar o comando git clone informando a URL do reposit√≥rio a ser clonado:
$ git clone file://192.168.1.1/opt/repositorios/
moveis-ecologicos.git

Ser√° exibida uma mensagem como:
Cloning into ‚Äôprojeto‚Äô...
remote: Counting objects: 8, done.
remote: Compressing objects: 100% (6/6), done.
remote: Total 8 (delta 1), reused 0 (delta 0)
Receiving objects: 100% (8/8), 618.32 KiB | 0 bytes/s, done.
Resolving deltas: 100% (1/1), done.
Checking connectivity... done.

66

Casa do C√≥digo

Cap√≠tulo 4. Trabalhando com reposit√≥rio remoto

Ao executar o comando anterior, o Git criar√° um diret√≥rio chamado
moveis-ecologicos, que ser√° uma c√≥pia local do reposit√≥rio remoto, contendo todos os arquivos e o hist√≥rico dos commits realizados.
Por padr√£o, o Git criar√° um diret√≥rio com o mesmo nome do reposit√≥rio,
e tamb√©m j√° adicionar√° um reposit√≥rio remoto com o name origin, que
aponta para a URL clonada.

4.5

Sincronizando o reposit√≥rio local

Ap√≥s clonar o reposit√≥rio do projeto, o novo desenvolvedor finalizou uma
das novas funcionalidades, realizando alguns commits para isso, e inclusive
j√° enviou tais commits para o servidor.
Sendo assim, para que possamos visualizar as altera√ß√µes e commits realizados pelo novo desenvolvedor, devemos sincronizar o nosso reposit√≥rio
local com o servidor, puxando os novos commits para o nosso reposit√≥rio
local.
A sincroniza√ß√£o do reposit√≥rio local com o servidor √© feita com o uso do
comando git pull, onde devemos informar o name do reposit√≥rio remoto
que queremos sincronizar, e o nome da branch local a ser atualizada:
$ git pull servidor master

Ser√° exibida uma mensagem como:
remote: Counting objects: 3, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 2 (delta 1), reused 0 (delta 0)
Unpacking objects: 100% (2/2), done.
From file://192.168.1.1/opt/repositorios/moveis-ecologicos
* branch
master
-> FETCH_HEAD
0000000..0000000 master
-> servidor/master
Updating 0000000..0000000
Fast-forward
promocoes.html | 0
1 file changed, 0 insertions(+), 0 deletions(-)
create mode 100111 promocoes.html

67

4.6. Protocolos suportados pelo Git

Casa do C√≥digo

Agora nosso reposit√≥rio local est√° atualizado, e j√° √© poss√≠vel visualizar as
altera√ß√µes e commits efetuados pelo novo desenvolvedor.

Reposit√≥rio centralizado ou distribu√≠do
O Git √© um sistema de controle de vers√£o distribu√≠do, e por isso n√£o
depende de um servidor central, diferentemente do CVS e SVN. Conforme visto no cap√≠tulo anterior, podemos trabalhar apenas com o reposit√≥rio local.
Entretanto, conforme visto neste cap√≠tulo, √© poss√≠vel trabalhar com o
Git de maneira centralizada, onde um servidor ser√° o reposit√≥rio central,
recebendo os commits de todos os desenvolvedores, e estes, por sua vez,
sincronizando seus reposit√≥rios locais com o servidor, frequentemente,
para obter os novos commits. Esta √© a maneira mais comum de utiliza√ß√£o
do Git.

4.6 Protocolos suportados pelo Git
Quando adicionamos ou clonamos um reposit√≥rio Git, devemos informar a
url do reposit√≥rio, que utiliza algum protocolo para comunica√ß√£o e transfer√™ncia de dados.
O Git suporta quatro protocolos para comunica√ß√£o e transfer√™ncia de dados:
‚Ä¢ Local
‚Ä¢ SSH
‚Ä¢ Git
‚Ä¢ HTTP/HTTPS

Protocolo local
O protocolo local foi o utilizado neste cap√≠tulo. Ele pode ser utilizado
quando o reposit√≥rio remoto estiver localizado no mesmo computador em
68

Casa do C√≥digo

Cap√≠tulo 4. Trabalhando com reposit√≥rio remoto

que se encontra o reposit√≥rio local, ou em outro computador que esteja conectado na mesma rede.
A utiliza√ß√£o do protocolo local √© feita com o uso do prefixo file:// na
URL do reposit√≥rio a ser clonado:
$ git clone file:///opt/repositorios/moveis-ecologicos.git

√â poss√≠vel omitir o prefixo file:// na URL, bastando apenas informar
o caminho do reposit√≥rio:
$ git clone /opt/repositorios/moveis-ecologicos.git

As vantagens da utiliza√ß√£o do protocolo local s√£o a sua simplicidade, e o
uso das permiss√µes existentes de acesso a arquivos e diret√≥rios. J√° uma das
desvantagens √© a dificuldade de configura√ß√£o para acesso externo √† rede.

Protocolo SSH
O protocolo SSH √©, provavelmente, o mais utilizado, por ser r√°pido, seguro, simples de configurar e por suportar tanto a leitura quanto a escrita de
dados.
O uso do protocolo SSH √© feito com a URL seguindo o padr√£o
usuario@servidor:/caminho/repositorio.git. Por exemplo:
$ git clone root@192.168.1.1:/opt/repositorios/
moveis-ecologicos.git

Protocolo Git
O Git possui um protocolo pr√≥prio, que √© similar ao SSH, mas sem o mecanismo de autentica√ß√£o. Por conta disso, ele acaba sendo mais r√°pido; entretanto n√£o √© seguro, e seu uso √© apenas para leitura.
Para clonar um reposit√≥rio utilizando o protocolo Git, a URL deve possuir
o prefixo git://:
$ git clone git://192.168.1.1/opt/repositorios/
moveis-ecologicos.git

69

4.6. Protocolos suportados pelo Git

Casa do C√≥digo

Protocolo HTTP/HTTPS
O Git tamb√©m suporta o protocolo HTTP, que √© bastante utilizado
quando estamos trabalhando em empresas que possuem um controle r√≠gido
de seguran√ßa, e a porta 22, utilizada pelo protocolo SSH, √© bloqueada.
Para clonar um reposit√≥rio utilizando o protocolo HTTP, a URL deve possuir o prefixo http://:
$ git clone http://192.168.1.1/opt/repositorios/
moveis-ecologicos.git

Tamb√©m √© poss√≠vel utilizar o protocolo HTTPS, que adiciona uma camada de seguran√ßa sobre o HTTP, com a utiliza√ß√£o do protocolo SSL/TLS:
$ git clone https://192.168.1.1/opt/repositorios/
moveis-ecologicos.git

70

Cap√≠tulo 5

Hospedando o reposit√≥rio no
GitHub
No cap√≠tulo anterior, vimos como utilizar um reposit√≥rio remoto, para que
tenhamos facilidade ao trabalhar em equipe no projeto. Agora, sempre que
um novo membro da equipe for trabalhar no projeto, ele deve primeiramente
clonar o reposit√≥rio, efetuar as altera√ß√µes necess√°rias, comitar tais altera√ß√µes,
e ent√£o enviar os commits para o reposit√≥rio remoto.
Assim sendo, vimos que a utiliza√ß√£o de um reposit√≥rio remoto nos ajuda
a ter uma melhor organiza√ß√£o para trabalhar em equipe em um projeto, al√©m
de tamb√©m funcionar como backup.
Entretanto, como o reposit√≥rio remoto est√° localizado em um servidor
da empresa, ficamos limitados a efetuar a sincroniza√ß√£o apenas dentro dela,
pois precisaremos estar conectados √† rede local para conseguirmos acessar o

5.1. Servi√ßos de hospedagem de projetos

Casa do C√≥digo

servidor.
Se algum dia um desenvolvedor precisar sincronizar as altera√ß√µes com o
reposit√≥rio remoto de fora da empresa, por exemplo de casa, isso n√£o vai ser
poss√≠vel, pois ele n√£o vai estar conectado √† rede local.
At√© √© poss√≠vel acessar a rede local da empresa externamente, mas para
isso ser√° necess√°rio configurar uma VPN (Virtual Private Network), ou liberar
acesso externo ao servidor via SSH, o que pode ser algo complicado de se
fazer, al√©m de tamb√©m poder ser proibido por algumas empresas, devido a
pol√≠ticas de seguran√ßa.
O ideal seria que o reposit√≥rio remoto estivesse acess√≠vel pela internet,
pois assim poder√≠amos acess√°-lo de qualquer lugar do mundo, bastando apenas estarmos conectados √† internet.

5.1 Servi√ßos de hospedagem de projetos
Existem alguns servi√ßos para hospedagem de projetos na internet, que permitem a utiliza√ß√£o de ferramentas de controle de vers√£o. A ideia √© que voc√™
possa hospedar seus projetos, juntamente com os reposit√≥rios, na internet, e
assim ser√° poss√≠vel acess√°-los de qualquer lugar do mundo.
Dentre os principais servi√ßos que suportam o Git, est√£o:
‚Ä¢ GitHub
‚Ä¢ Bitbucket
‚Ä¢ Google Code

5.2 GitHub: a rede social dos desenvolvedores
Criado em 2008 por Tom Preston-Werner, Chris Wanstrath e PJ Hyett, com
o objetivo de simplificar o compartilhamento de projetos, o GitHub √© hoje o
maior servi√ßo de hospedagem de reposit√≥rios de projetos, contendo, atualmente, mais de 3 milh√µes de usu√°rios e mais de 12 milh√µes de reposit√≥rios.

72

Casa do C√≥digo

Cap√≠tulo 5. Hospedando o reposit√≥rio no GitHub

Figura 5.1: Logotipo do GitHub

√â o principal servi√ßo utilizado pelos desenvolvedores que utilizam o Git.
V√°rios projetos importantes est√£o hospedados no GitHub, dentre eles:
‚Ä¢ jQuery
‚Ä¢ Ruby on Rails
‚Ä¢ Node.js
‚Ä¢ Django
‚Ä¢ Bootstrap
O GitHub √© tamb√©m uma ferramenta colaborativa, pois nos permite interagir nos reposit√≥rios, por meio de algumas funcionalidades como:
‚Ä¢ Issue Tracker: para cria√ß√£o e gest√£o de bugs e milestones do projeto;
‚Ä¢ Pull Requests: para que outros usu√°rios possam enviar seus commits
com altera√ß√µes no projeto, ou commits com corre√ß√µes de bugs;
‚Ä¢ Commit Comments: para que os usu√°rios possam comentar e discutir
sobre as modifica√ß√µes no c√≥digo, de um determinado commit.
Al√©m disso, no GitHub √© poss√≠vel criar organiza√ß√µes, e dentro delas criar
equipes, para que ent√£o seja poss√≠vel vincular determinados usu√°rios a determinadas equipes, bem como vincular as equipes aos reposit√≥rios em que elas
73

5.3. Encontrando projetos e visualizando o c√≥digo-fonte

Casa do C√≥digo

v√£o trabalhar. Isso √© muito √∫til para empresas que possuem muitos projetos e
muitos colaboradores, pois permite uma melhor organiza√ß√£o.
Por conta dessas funcionalidades e por permitir uma maior colabora√ß√£o
nos reposit√≥rios, o GitHub √© considerado por muitos como uma esp√©cie de
rede social para desenvolvedores.

5.3 Encontrando projetos e visualizando o
c√≥digo-fonte
Vamos acessar o site do GitHub e visualizar o c√≥digo-fonte de algum projeto
open source. Para isso, basta abrir um navegador e acessar o endere√ßo: http:
//github.com

Figura 5.2: P√°gina inicial do GitHub

Essa √© a p√°gina inicial do GitHub, nela podemos efetuar login, cadastrar
um novo usu√°rio, fazer buscas e acessar alguns links interessantes.
No topo da p√°gina existe um campo de texto, usado para pesquisar por
reposit√≥rios ou usu√°rios. Vamos pesquisar pelo reposit√≥rio do jQuery, uma
famosa biblioteca de JavaScript, bastando para isso digitar a palavra jquery
no campo de texto e apertar a tecla Enter.

74

Casa do C√≥digo

Cap√≠tulo 5. Hospedando o reposit√≥rio no GitHub

Figura 5.3: Campo para pesquisar por reposit√≥rios

Ap√≥s realizar a pesquisa, ser√° apresentada uma p√°gina com o resultado,
listando todos os reposit√≥rios que possuam no nome ou na descri√ß√£o a palavra
jquery.

Figura 5.4: P√°gina com o resultado da pesquisa

Vamos selecionar o primeiro resultado, que no caso √© o projeto jQuery
que estamos buscando.

Figura 5.5: Link para o reposit√≥rio do jQuery

75

5.3. Encontrando projetos e visualizando o c√≥digo-fonte

Casa do C√≥digo

Na p√°gina do reposit√≥rio do jQuery √© poss√≠vel navegar pelo c√≥digo-fonte,
visualizar a descri√ß√£o do projeto, os commits, os usu√°rios que contribuem
para o projeto, e at√© mesmo baixar o reposit√≥rio compactado em um arquivo
zip.

Figura 5.6: P√°gina do reposit√≥rio do jQuery

Visualizando os commits do projeto
Vamos agora visualizar os √∫ltimos commits realizados no projeto. Para
isso, basta clicar no link commits:

Figura 5.7: Link para a p√°gina de commits do jQuery

Ser√° apresentada uma p√°gina listando os √∫ltimos commits efetuados no
76

Casa do C√≥digo

Cap√≠tulo 5. Hospedando o reposit√≥rio no GitHub

projeto, onde tamb√©m √© poss√≠vel navegar por commits mais antigos. Visualizar esta p√°gina seria como executar o comando git log no reposit√≥rio.

Figura 5.8: P√°gina de commits do jQuery

Ao clicar em algum dos commits, ser√° apresentada uma p√°gina de detalhamento, onde podemos visualizar as altera√ß√µes efetuadas, similar a quando
executamos o comando git diff:

77

5.3. Encontrando projetos e visualizando o c√≥digo-fonte

Casa do C√≥digo

Figura 5.9: P√°gina de detalhamento de commit

Visualizando o c√≥digo-fonte do projeto
De volta √† p√°gina principal do reposit√≥rio, agora vamos navegar pelo
c√≥digo-fonte. J√° na p√°gina principal do reposit√≥rio √© poss√≠vel visualizar os
arquivos e diret√≥rios do projeto. Vamos navegar pelo diret√≥rio src:

78

Casa do C√≥digo

Cap√≠tulo 5. Hospedando o reposit√≥rio no GitHub

Figura 5.10: Diret√≥rios do reposit√≥rio

Ser√£o exibidos todos os arquivos e subdiret√≥rios existentes, e podemos
detalhar algum deles, por exemplo o arquivo ajax.js:

79

5.4. Criando um usu√°rio no GitHub

Casa do C√≥digo

Figura 5.11: Detalhamento de um dos arquivos do reposit√≥rio

Al√©m de ser exibido todo o c√≥digo-fonte do arquivo, nessa p√°gina tamb√©m √© poss√≠vel visualizar todos os usu√°rios que j√° efetuaram commits com
modifica√ß√µes neste arquivo.

5.4

Criando um usu√°rio no GitHub

Para poder come√ßar a usar o GitHub e criar os nossos reposit√≥rios, devemos
primeiramente cadastrar um novo usu√°rio no site.
Aten√ß√£o! Caso voc√™ j√° tenha criado um usu√°rio anteriormente, no cap√≠tulo 2 voc√™ pode seguir para a pr√≥xima se√ß√£o.
A cria√ß√£o de um novo usu√°rio no GitHub deve ser feita na p√°gina inicial
do site: http://github.com

80

Casa do C√≥digo

Cap√≠tulo 5. Hospedando o reposit√≥rio no GitHub

Figura 5.12: P√°gina de cria√ß√£o de novo usu√°rio

Devemos informar um nome de usu√°rio, o e-mail e uma senha. Caso j√°
exista um outro usu√°rio cadastrado com o mesmo nome de usu√°rio e/ou email informado, o GitHub nos mostrar√° um alerta indicando tal situa√ß√£o, e
s√≥ permitir√° que continuemos o cadastro ap√≥s a altera√ß√£o dessa(s) informa√ß√£o(√µes).
Ap√≥s informar os dados e clicar no bot√£o Sign up for GitHub, seremos
redirecionados para uma p√°gina de boas-vindas, onde devemos escolher qual
o plano a ser contratado.

81

5.4. Criando um usu√°rio no GitHub

Casa do C√≥digo

Figura 5.13: P√°gina de boas-vindas e escolha do plano de contrata√ß√£o

Planos de contrata√ß√£o oferecidos pelo GitHub
O GitHub possui alguns planos que podemos contratar, sendo um gratuito, e os outros com custos mensais.
No plano gratuito do GitHub, o usu√°rio n√£o tem nenhum custo, entretanto ele somente poder√° criar reposit√≥rios p√∫blicos, ou seja, qualquer pessoa poder√° encontrar seus reposit√≥rios e inclusive ter acesso ao c√≥digo-fonte.
Este plano √© ideal para usu√°rios que querem criar e/ou colaborar com projetos
open source.
Mas muitas empresas possuem projetos que s√£o restritos, e n√£o podem
ter o c√≥digo-fonte acess√≠vel a qualquer pessoa. Neste caso, a empresa dever√°
contratar algum dos planos pagos oferecidos pelo GitHub.
A diferen√ßa entre os planos pagos est√° na quantidade de reposit√≥rios pri82

Casa do C√≥digo

Cap√≠tulo 5. Hospedando o reposit√≥rio no GitHub

vados que poder√£o ser criados. No plano mais barato, que atualmente custa
$7 por m√™s, √© poss√≠vel criar at√© 5 reposit√≥rios privados, enquanto que no plano
mais caro, que atualmente custa $50 por m√™s, essa quantidade de reposit√≥rios
privados sobe para 50.
Ap√≥s escolher o plano que mais se adeque √†s nossas necessidades, devemos finalizar o cadastro clicando no bot√£o Finish sign up, e seremos redirecionados para a p√°gina que mostra os reposit√≥rios do nosso usu√°rio e outras
informa√ß√µes. Essa p√°gina √© conhecida como Dashboard.

Figura 5.14: P√°gina de dashboard

O GitHub enviar√° um e-mail de confirma√ß√£o de cadastro, com um link
para valida√ß√£o e ativa√ß√£o. √â importante acessarmos esse link, pois assim o
e-mail ser√° validado e associado ao nosso usu√°rio, e al√©m disso, todas as notifica√ß√µes do GitHub ser√£o enviadas apenas ao(s) e-mail(s) cadastrado(s).

5.5 Criando o reposit√≥rio do projeto
Agora que temos um usu√°rio cadastrado, j√° √© poss√≠vel criar o reposit√≥rio do
projeto.
Para criar um novo reposit√≥rio no GitHub, devemos acessar a URL http:
//github.com/new ou clicar no bot√£o New repository existente na p√°gina
principal.
83

5.5. Criando o reposit√≥rio do projeto

Casa do C√≥digo

Figura 5.15: P√°gina de cria√ß√£o de novo reposit√≥rio

Nesta p√°gina devemos preencher o nome do reposit√≥rio no campo
Repository name, e, opcionalmente, preencher uma descri√ß√£o no campo
Description. Ap√≥s isso, basta clicar no bot√£o Create repository, e
seremos redirecionados para a p√°gina principal do reposit√≥rio, onde ser√£o
exibidas as informa√ß√µes de como adicionar o reposit√≥rio remoto, para podermos sincronizar os commits do nosso reposit√≥rio local.

84

Casa do C√≥digo

Cap√≠tulo 5. Hospedando o reposit√≥rio no GitHub

Figura 5.16: P√°gina do novo reposit√≥rio

Agora basta adicionarmos o reposit√≥rio remoto, com o comando git
remote add, conforme exibido na p√°gina do reposit√≥rio:
$ git remote add origin
https://github.com/fulanodasilva/moveis-ecologicos.git

5.6

Enviando os commits do projeto para o
GitHub

Com o reposit√≥rio remoto adicionado, podemos finalmente enviar os commits para o GitHub.
O envio dos commits √© feito da mesma maneira que vimos no cap√≠tulo
anterior, ou seja, utilizando o comando git push:
$ git push origin master

Como utilizamos o protocolo https ao adicionar o reposit√≥rio remoto,
sempre que formos sincronizar nosso reposit√≥rio local, o Git nos solicitar√° o
usu√°rio e senha cadastrados no GitHub.
85

5.7. Clonando o reposit√≥rio hospedado no GitHub

Casa do C√≥digo

Ap√≥s o Git enviar os commits para o reposit√≥rio remoto, ser√° exibida uma
mensagem como:
Counting objects: 8, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (6/6), done.
Writing objects: 100% (8/8), 15.78 KiB | 0 bytes/s, done.
Total 8 (delta 0), reused 0 (delta 0)
To https://github.com/fulanodasilva/moveis-ecologicos.git
* [new branch]
master -> master

Se atualizarmos a p√°gina do nosso reposit√≥rio, veremos que os arquivos
e os commits foram enviados com sucesso:

Figura 5.17: P√°gina do reposit√≥rio atualizada com os arquivos e commits

5.7 Clonando o reposit√≥rio hospedado no
GitHub
Agora que o nosso reposit√≥rio remoto est√° hospedado no GitHub, os desenvolvedores da equipe poder√£o sincronizar seus reposit√≥rios locais de qualquer
lugar do mundo, n√£o ficando mais restritos a sincronizar apenas quando conectados na rede local da empresa.
86

Casa do C√≥digo

Cap√≠tulo 5. Hospedando o reposit√≥rio no GitHub

Para que um novo desenvolvedor obtenha uma c√≥pia do reposit√≥rio, ele
agora dever√° clonar o reposit√≥rio remoto localizado no GitHub:
$ git clone https://github.com/fulanodasilva/
moveis-ecologicos.git

5.8

Colaborando com projetos open source

Conforme citado anteriormente, existem milhares de projetos hospedados no
GitHub, sendo que muitos destes s√£o open source, ou seja, significa que qualquer desenvolvedor pode colaborar com melhorias e corre√ß√µes de bugs. Mas
como fazer para colaborar com tais projetos?
Vamos supor que queremos colaborar com algum projeto open source,
por exemplo, o VRaptor, um framework MVC para desenvolvedores Java.

Figura 5.18: P√°gina do reposit√≥rio do VRaptor

Primeiramente vamos precisar clonar o reposit√≥rio, para termos acesso
ao c√≥digo-fonte, e ent√£o efetuar as melhorias desejadas:
$ git clone https://github.com/caelum/vraptor4.git

87

5.8. Colaborando com projetos open source

Casa do C√≥digo

Pronto! J√° temos uma c√≥pia do reposit√≥rio com todos os arquivos do
projeto. Agora basta efetuar as melhorias desejadas, registrando as altera√ß√µes
realizadas com commits.
Mas lembre-se de que os commits realizados existem apenas no nosso
reposit√≥rio local, precisamos agora envi√°-los para o reposit√≥rio remoto do
projeto, no GitHub, com o comando git push:
$ git push origin master

Entretanto, a execu√ß√£o do comando anterior falha, gerando a seguinte
mensagem de erro:
remote: Permission to caelum/vraptor4.git denied to
fulanodasilva.
fatal: unable to access ‚Äôhttps://github.com/caelum/
vraptor4.git/‚Äô:
The requested URL returned error: 403

O problema √© que o usu√°rio fulanodasilva n√£o tem permiss√£o para
enviar commits para o reposit√≥rio do VRaptor, pois esse reposit√≥rio n√£o pertence a ele, mas sim ao usu√°rio caelum.
Para resolver esse problema, o usu√°rio caelum poderia acessar a p√°gina
de configura√ß√µes do reposit√≥rio VRaptor no GitHub, e adicionar o usu√°rio
fulanodasilva como colaborador.
Mas essa abordagem deve ser utilizada apenas para adicionar os usu√°rios
que fazem parte da equipe de desenvolvimento do projeto, ou seja, apenas os
desenvolvedores que trabalham efetivamente no projeto. Dessa forma, acaba
sendo invi√°vel ter que adicionar um novo usu√°rio como colaborador toda vez
que um novo desenvolvedor quiser colaborar com o projeto.
Al√©m disso, a partir do momento em que adicionamos um usu√°rio como
colaborador, ele passa a ter permiss√£o de enviar commits para o reposit√≥rio
sem restri√ß√µes, o que pode ser arriscado, pois n√£o h√° uma avalia√ß√£o pr√©via
das altera√ß√µes que foram realizadas.

88

Casa do C√≥digo

Cap√≠tulo 5. Hospedando o reposit√≥rio no GitHub

Pull requests
A solu√ß√£o do GitHub para a colabora√ß√£o com projetos open source, foi
uma funcionalidade chamada de pull requests.
Primeiramente, devemos acessar a p√°gina do projeto que queremos colaborar no GitHub, no nosso caso http://github.com/caelum/vraptor4, e clicar
no bot√£o Fork:

Figura 5.19: Bot√£o para fazer o fork do VRaptor

Ao clicar no bot√£o Fork, o GitHub criar√° uma c√≥pia do reposit√≥rio do
VRaptor no nosso usu√°rio do GitHub:

Figura 5.20: P√°gina do reposit√≥rio do VRaptor pertencente ao nosso usu√°rio

Repare que agora o nosso usu√°rio do GitHub possui um reposit√≥rio chamado vraptor4, ou seja, esse reposit√≥rio √© a nossa vers√£o do projeto.
O pr√≥ximo passo √© clonar o reposit√≥rio a partir do nosso usu√°rio do
GitHub, e n√£o do usu√°rio caelum, pois assim conseguiremos realizar o push
dos commits locais para o nosso reposit√≥rio no GitHub:
$ git clone https://github.com/fulanodasilva/vraptor4.git

89

5.8. Colaborando com projetos open source

Casa do C√≥digo

Agora, ap√≥s realizar as altera√ß√µes e commits no projeto, conseguiremos
realizar o push normalmente, pois o reposit√≥rio remoto no GitHub pertence
ao nosso usu√°rio.
Entretanto, os commits foram enviados apenas para o nosso reposit√≥rio
no GitHub.
Para que os commits sejam integrados ao reposit√≥rio original do projeto,
no caso o reposit√≥rio vraptor4 do usu√°rio caelum, devemos enviar um
Pull Request para o usu√°rio caelum, solicitando que seja feito um pull dos
nossos commits.
Para criar um Pull Request devemos acessar a p√°gina do nosso reposit√≥rio no GitHub, clicar no link Pull Requests, e em seguida clicar no bot√£o
New pull request:

Figura 5.21: P√°gina com link para gerenciar Pull requests

Figura 5.22: P√°gina com bot√£o para criar um novo Pull request

Seremos redirecionados para a p√°gina de cria√ß√£o do pull request, na qual
ser√£o listados os commits e altera√ß√µes realizados. Para confirmar a cria√ß√£o do
pull request, basta clicar no bot√£o Create pull request:
90

Casa do C√≥digo

Cap√≠tulo 5. Hospedando o reposit√≥rio no GitHub

Figura 5.23: P√°gina com bot√£o para confirmar a cria√ß√£o do pull request

Ap√≥s criarmos o pull request, o usu√°rio caelum receber√° uma notifica√ß√£o do GitHub, e poder√° efetuar o pull dos nossos commits, integrandoos ao reposit√≥rio original do projeto. Claro, isso ap√≥s uma an√°lise das altera√ß√µes efetuadas em nossos commits.
Pronto! Esse √© o processo utilizado pelos desenvolvedores que colaboram
com projetos open source hospedados no GitHub.

91

Cap√≠tulo 6

Organizando o trabalho com
branches
Nosso cliente n√£o est√° satisfeito com o design da p√°gina. Convenhamos, a
p√°gina que criamos n√£o est√° das mais bonitas do mundo:

Figura 6.1: Design da p√°gina deixa a desejar

6.1. A branch master

Casa do C√≥digo

Sabemos um pouquinho sobre design, mas precisamos de algumas semanas focadas na melhoria do visual.
Mas temos um problema: nosso cliente continua pedindo para alterarmos o conte√∫do da p√°gina, v√°rias vezes por semana. Al√©m disso, temos que
corrigir bugs como erros de portugu√™s, links incorretos etc. E sabemos que
todas essas as mudan√ßas t√™m que ser publicadas de imediato.
Se publicarmos o site enquanto o novo design est√° sendo desenvolvido,
teremos uma p√°gina pela metade. E precisamos de tempo para experimentar
algumas possibilidades. E agora?

Trabalhando em paralelo com branches
A maioria dos sistemas de controle de vers√£o permite trabalho em paralelo atrav√©s de branches. Uma branch √© uma linha independente de desenvolvimento em que podemos comitar novas vers√µes do c√≥digo sem afetar outras
branches.
Em muitos sistemas de controle de vers√£o, utilizar branches √© algo bastante lento e trabalhoso. Por√©m, a estrutura interna do Git permite lidarmos
com branches de maneira muito r√°pida e leve.

6.1

A branch master

Vamos nos certificar de que estamos no nosso reposit√≥rio moveis, executando cd ~/moveis em um terminal.
Para listar as branches do nosso reposit√≥rio, devemos executar o comando:
$ git branch

Teremos como resposta:
* master

Pera√≠! Foi mostrada uma branch chamada master, mesmo sem termos
criados nenhuma branch... Isso ocorreu porque o Git possui por padr√£o uma
branch principal chamada master. Todos os nossos commits at√© agora ocorreram nessa branch principal.
94

Casa do C√≥digo

Cap√≠tulo 6. Organizando o trabalho com branches

Observe que a branch master tem um asterisco (*) na frente. Isso indica
que √© a branch atual, em que estamos trabalhando.
No Git, toda branch √© basicamente um apontador para um commit. A
cada novo commit que fazemos, a branch √© movida automaticamente, passando a apontar para esse novo commit. Por isso, por padr√£o, a branch
master aponta para o √∫ltimo commit que fizemos.
Se quisermos listar as branches existentes no nosso reposit√≥rio com os
commits associados, poder√≠amos utilizar a op√ß√£o -v do comando git
branch:
$ git branch -v

A resposta, no nosso caso, seria:
* master b92285b Revert "Adicionando texto peculiar"

Antes de continuarmos, √© importante sabermos uma das informa√ß√µes que
um commit armazena, o commit pai, que √© o que foi efetuado anteriormente.
Na verdade, um commit pode ter v√°rios pais, o que veremos adiante.
Podemos observar os commits com seus respectivos pais executando o
comando git log com a op√ß√£o --parents.
J√° para verificarmos o commit para o qual a master est√° apontando,
passamos a op√ß√£o --decorate para o comando git log.
Juntando as op√ß√µes, podemos executar
git log --oneline
--decorate --parents para exibir o hist√≥rico resumido do nosso
reposit√≥rio com o commit para o qual a master est√° apontado e os commits
pai de cada commit. Ter√≠amos uma sa√≠da parecida com:
b92285b a5b9fce (HEAD, master) Revert "Adicionando texto
peculiar"
a5b9fce 2259f55 Adicionando texto peculiar
2259f55 d211fac Movendo principal.js
d211fac 515da0a Renomeando CSS
515da0a e9ca4c6 Removendo p√°gina de produtos
e9ca4c6 793e567 P√°gina de produtos
793e567 0f2b749 Diminuindo intervalo de troca de banner
0f2b749 7e1c195 Banner ao abrir pagina

95

Casa do C√≥digo

6.2. Criando uma branch

7e1c195
9a20490
83b60c3
1a02a4f

9a20490 Inserindo arquivo principal.js
83b60c3 Script de troca de banner
1a02a4f Inserindo titulo e diminuindo tamanho da pagina
Commit inicial

Observe que a resposta do comando anterior apresenta tr√™s colunas: o
c√≥digo do commit, o c√≥digo do pai e a mensagem do commit. Por exemplo, podemos ver que o pai do commit d211fac (‚ÄúRenomeando CSS‚Äù) foi o
commit 515da0a (‚ÄúRemovendo p√°gina de produtos‚Äù).
Note tamb√©m que nosso primeiro commit, o de c√≥digo 1a02a4f, possui
apenas duas colunas, indicando que esse commit n√£o possui um pai.
Al√©m disso, podemos ver que a branch master aponta para o √∫ltimo
commit, de c√≥digo b92285b. N√£o se preocupe com o HEAD, j√° que veremos
a seguir seu significado.
Uma visualiza√ß√£o do nosso hist√≥rico de commits da branch master seria:

Figura 6.2: A branch master

6.2

Criando uma branch

Para criarmos uma branch chamada design para trabalharmos na melhoria
do design basta executarmos:
$ git branch design

N√£o ser√° exibida nenhuma resposta.
Se listarmos as branches com o comando git branch, teremos:
96

Casa do C√≥digo

Cap√≠tulo 6. Organizando o trabalho com branches

design
* master

Agora temos duas branches!
Note que a branch atual continua sendo a master, que est√° destacada
com um asterisco (*). O comando git branch apenas cria uma nova
branch, mas n√£o muda para a branch criada.
A nova branch que acabamos de criar ( design) aponta para o mesmo
commit que a branch que est√°vamos anteriormente ( master). Podemos verificar isso com o comando git branch -v:
design b92285b Revert "Adicionando texto peculiar"
* master b92285b Revert "Adicionando texto peculiar"

Mas onde o Git guarda a informa√ß√£o de qual √© a branch atual? A√≠ que
entra o HEAD, que √© um apontador especial que indica qual √© a branch na
qual estamos trabalhando.
Visualizando o nosso reposit√≥rio logo ap√≥s a cria√ß√£o da branch design,
ter√≠amos:

Figura 6.3: A branch design e o HEAD

97

6.3. Trocando de branch

6.3

Casa do C√≥digo

Trocando de branch

J√° criamos nossa branch design mas ainda estamos na master. Para trocarmos para a branch recentemente criada, devemos executar:
$ git checkout design

Deve aparecer como resposta:
Switched to branch ‚Äôdesign‚Äô

Depois de executar o comando anterior, o HEAD passa a apontar para a
nova branch design.
Se executarmos o comando git branch -v, teremos:
* design b92285b Revert "Adicionando texto peculiar"
master b92285b Revert "Adicionando texto peculiar"

Observe que o asterisco (*) que indica a branch atual foi mudada para a
branch design. Ambas as branches continuam apontando para o mesmo
commit.
Visualizando o estado do nosso reposit√≥rio, ter√≠amos:

Figura 6.4: HEAD apontando para design

98

Casa do C√≥digo

Cap√≠tulo 6. Organizando o trabalho com branches

Conforme vimos no cap√≠tulo 3, o comando git checkout, al√©m de
trocar a branch atual, tamb√©m pode ser usado para descartar mudan√ßas
de um arquivo que ainda n√£o est√£o na √°rea de stage. Para descartarmos
as mudan√ßas do arquivo index.html, por exemplo, devemos executar
git checkout -- index.html.
Na verdade, a op√ß√£o -- n√£o √© estritamente necess√°ria. Por√©m, √© uma
boa pr√°tica, j√° que serve para informar que se trata de um arquivo. Dessa
maneira, ajuda a evitar problemas caso uma branch tenha o mesmo nome
de algum arquivo.

Criando e j√° trocando para uma nova branch
Nosso cliente pediu que n√≥s come√ß√°ssemos a construir uma loja online
para venda dos m√≥veis. Seria algo demorado, de longo prazo. Por isso, construir√≠amos a loja online uma nova branch, chamada loja.
Criar uma branch loja com git branch s√≥ para depois mudar para
a nova branch com git checkout √© algo tedioso.
Seria interessante j√° criarmos e mudarmos para a nova branch loja de
uma s√≥ vez. Podemos fazer isso passando a op√ß√£o -b para o comando git
checkout:
$ git checkout -b loja

A sa√≠da apresentada seria:
Switched to a new branch ‚Äôloja‚Äô

Se listarmos as branches com git branch -v, ter√≠amos:
design b92285b Revert "Adicionando texto peculiar"
* loja
b92285b Revert "Adicionando texto peculiar"
master b92285b Revert "Adicionando texto peculiar"

Note que o asterisco (*) est√° na branch loja, indicando que essa √© a
branch atual. E a loja foi criada apontando para o commit b92285b, o
mesmo das outras branches.
99

6.4. Deletando uma branch

6.4

Casa do C√≥digo

Deletando uma branch

Mas n√£o temos tempo para criar uma loja online... Temos que nos focar nas
nossas tarefas atuais.
Como n√£o vamos usar a branch loja por um bom tempo, seria bom
remov√™-la. Assim, evitamos confus√µes e desperd√≠cio no nosso reposit√≥rio.
N√£o √© poss√≠vel remover uma branch enquanto estivermos nela. Por isso,
devemos ir para outra branch. Para ir para a branch master, devemos executar git checkout master.
Para deletar uma branch, devemos utilizar a op√ß√£o -d do comando git
branch:
$ git branch -d loja

Deve aparecer uma mensagem como a seguir:
Deleted branch loja (was b92285b).

A branch loja foi deletada. Nosso reposit√≥rio est√° limpo e cristalino!
Se j√° tiv√©ssemos feito algum commit na branch loja, ao executarmos
git branch -d loja ter√≠amos como resposta:
error: The branch ‚Äôloja‚Äô is not fully merged.
If you are sure you want to delete it, run ‚Äôgit branch -D loja‚Äô.

N√£o √© poss√≠vel deletar com a op√ß√£o -d uma branch que possui commits
ainda n√£o aplicados em outras branches (veremos como mesclar branches
mais adiante).
Para removermos a branch loja se tivermos feito algum commit, devemos utilizar a op√ß√£o -D:
$ git branch -D loja

Ter√≠amos na sa√≠da:
Deleted branch loja (was b92285b).

Agora sim! Os commits da branch loja seriam descartados e a branch
seria removida.
100

Casa do C√≥digo

Cap√≠tulo 6. Organizando o trabalho com branches

6.5 Comitando c√≥digo em uma nova branch
Decidimos utilizar uma ferramenta para auxiliar na melhoria do design: o
Bootstrap.
A primeira coisa √© certificar-nos que estamos na branch design, executando git checkout design.
Depois disso, vamos alterar o index.html, trocando nosso CSS feio
pelo CSS do Bootstrap e colocando o atributo class em algumas tags:
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<meta name="description" content="M√≥veis ecol√≥gicos">
<meta name="keywords" content="moveis ecologicos">
<link rel="stylesheet"
href="http://netdna.bootstrapcdn.com/bootstrap/3.1.1/
css/bootstrap.min.css">
<title>M√≥veis Ecol√≥gicos</title>
<script src="js/principal.js"></script>
</head>
<body onload="trocaBanner();">
<div class="container">
<div class="jumbotron">
<h1>M√≥veis Ecol√≥gicos S. A.</h1>
<h2 id="mensagem"></h2>
<ul class="list-group">
<li class="list-group-item">
M√≥veis de garrafas PET
</li>
<li class="list-group-item">
M√≥veis de latinhas de alum√≠nio
</li>
<li class="list-group-item">
M√≥veis de papel√£o
</li>
</ul>
</div>
</div>

101

6.5. Comitando c√≥digo em uma nova branch

Casa do C√≥digo

</body>
</html>

Apenas com essas pequenas altera√ß√µes, embelezamos um bocado nossa
p√°gina:

Figura 6.5: P√°gina embelezada

Tamb√©m vamos remover o nosso CSS antigo, para n√£o ficarmos com c√≥digo obsoleto, executando o comando git rm principal.css.
Agora, vamos adicionar √† √°rea de stage as altera√ß√µes e comit√°-las com o
comando git commit -am "Adicionando Bootstrap".
Na sa√≠da, ser√° impresso:
[design 8f53065] Adicionando Bootstrap
2 files changed, 23 insertions(+), 19 deletions(-)
delete mode 100111 principal.css

Observe no texto anterior que foi exibido o nome da branch design, em
que estamos comitando.
Ao executarmos o comando
git log -n 3 --oneline
--decorate --parents, ter√≠amos:
8f53065 b92285b (HEAD, design) Adicionando Bootstrap
b92285b a5b9fce (master) Revert "Adicionando texto peculiar"
a5b9fce 2259f55 Adicionando texto peculiar

102

Casa do C√≥digo

Cap√≠tulo 6. Organizando o trabalho com branches

Note que a branch master ainda continua apontando para o commit de
c√≥digo b92285b (Revert ‚ÄúAdicionando texto peculiar‚Äù).
J√° a branch design passou a apontar para o novo commit, de c√≥digo
8f53065 (Adicionando Bootstrap). Observe tamb√©m que o HEAD aponta
para o mesmo commit.
Um gr√°fico representando o nosso commit na branch design seria:

Figura 6.6: Commit na branch design

6.6

Voltando para o master e fazendo uma altera√ß√£o

Ainda n√£o acabamos de embelezar a nossa p√°gina, mas nosso cliente nos ligou
pedindo que modific√°ssemos os textos do banner. E pediu que public√°ssemos
urgentemente as altera√ß√µes!
A primeira coisa que devemos fazer √© voltar para a branch master, executando o comando git checkout master.
Visualizando o estado do nosso reposit√≥rio nesse ponto, ter√≠amos:

103

6.6. Voltando para o master e fazendo uma altera√ß√£o

Casa do C√≥digo

Figura 6.7: Voltando √† branch master

Agora que estamos na branch master, vamos alterar os textos do banner
no arquivo principal.js:
var banners = ["Do lixo ao luxo!","Reaproveitar √© aproveitar!"];
//restante do arquivo

Em seguida, vamos comitar nossas altera√ß√µes com o comando git
commit -am "Alterando textos do banner". Ter√≠amos na sa√≠da:
[master 2223859] Alterando textos do banner
1 file changed, 1 insertion(+), 1 deletion(-)

Nesse ponto, nosso reposit√≥rio estaria parecido com:

104

Casa do C√≥digo

Cap√≠tulo 6. Organizando o trabalho com branches

Figura 6.8: Novo commit na master

Note que a branch master est√° apontando para o commit 2223859 que
acabamos de realizar. J√° a branch design continua apontando para o mesmo
commit que estava anteriormente.
Poder√≠amos ent√£o publicar com rapidez os novos banners sem as modifica√ß√µes de design, que ainda n√£o foram aprovadas.

6.7 Mesclando altera√ß√µes
Mostramos o novo design para o nosso cliente e ele gostou bastante. Pediu
para colocarmos no ar o que temos agora. E o mais r√°pido poss√≠vel!
Temos duas altera√ß√µes: os novos textos do banner, que est√£o na branch
master, e o embelezamento da p√°gina, que est√° na branch design.
Por isso, precisamos mesclar as altera√ß√µes que fizemos na branch design
com as que fizemos na master. Identificar o que mudou, copiando e colando
na m√£o √© um trabalho razo√°vel, com alta chance de inserirmos um erro. Ainda
bem que o Git vai nos ajudar a fazer isso!

105

6.7. Mesclando altera√ß√µes

Casa do C√≥digo

Verificando branches ainda n√£o mescladas
Considerando que estamos na branch master, podemos verificar as
branches ainda n√£o mescladas com a op√ß√£o --no-merged do comando git
branch:
$ git branch --no-merged

Ter√≠amos a seguinte sa√≠da:
design

Isso indica que h√° mudan√ßas ainda n√£o mescladas na branch design.
O comando git branch tamb√©m tem a op√ß√£o --merged. Se execut√°ssemos git branch --merged, ter√≠amos:
* master

Mesclando altera√ß√µes com merge
Para juntarmos todas as altera√ß√µes que fizemos na branch design com
as da branch master, mesclando as duas, podemos utilizar o comando:
$ git merge design -m "Mesclando com a branch design"

Ser√° exibida uma resposta semelhante √† seguinte:
Removing principal.css
Merge made by the ‚Äôrecursive‚Äô strategy.
index.html
| 31 +++++++++++++++++++++++-------principal.css | 11 ----------2 files changed, 23 insertions(+), 19 deletions(-)
delete mode 100111 principal.css

Pronto! Mudan√ßas mescladas! Ao executarmos o comando git
branch --no-merged, n√£o ter√≠amos nenhuma resposta, indicando que
n√£o h√° nenhuma branch n√£o mesclada.
Note que, depois do merge, o arquivo principal.css foi removido e
as altera√ß√µes que t√≠nhamos realizado em index.html foram trazidas para
106

Casa do C√≥digo

Cap√≠tulo 6. Organizando o trabalho com branches

a nossa branch atual, a master. Observe tamb√©m que os textos do banner
que modificamos continuam l√°.
Se n√£o tiv√©ssemos informado uma mensagem atrav√©s da op√ß√£o -m, seria
aberto um editor de texto.
√â importante saber que, quando √© efetuado um merge, √© criado um novo
commit com as altera√ß√µes que estamos mesclando e com a mensagem que
informamos.
Podemos verificar esse novo commit de merge executando o comando
git log -n 4 --oneline --decorate --parents. Ter√≠amos na
sa√≠da:
e6b2f35 2223859 8f53065 (HEAD, master) Mesclando com a branch
design
2223859 b92285b Alterando textos do banner
8f53065 b92285b (design) Adicionando Bootstrap
b92285b a5b9fce Revert "Adicionando texto peculiar"

Observe que a branch master e o HEAD apontam para o commit de
merge, que √© o √∫ltimo commit realizado, e que tem o c√≥digo e6b2f35 e a
mensagem que hav√≠amos informado.
J√° a branch design continua apontando para o mesmo commit que estava anteriormente.
√â importante notar que o commit de merge ( e6b2f35) tem dois commits
pai: o commit 2223859, de mensagem ‚ÄúAlterando textos do banner‚Äù, e o
commit 8f53065, de mensagem ‚ÄúAdicionando Bootstrap‚Äù.
Visualizando o estado do nosso reposit√≥rio depois do merge da branch
design na branch master, ter√≠amos:

107

Casa do C√≥digo

6.7. Mesclando altera√ß√µes

Figura 6.9: Merge de design na master

H√° uma situa√ß√£o em que um git merge n√£o ir√° gerar um commit
de merge: quando a branch de destino n√£o teve nenhum commit a mais
desde que a branch a ser mesclada foi criada.
No nosso caso, se n√£o tiv√©ssemos feito o commit 2223859 (Alterando textos do banner) na branch master, o merge com a branch
design seria basicamente apontar a master para onde a design
aponta: o commit 8f53065 (Adicionando Bootstrap).
Esse tipo de merge √© chamado de fast-forward.
√â poss√≠vel evitar o uso de fast-forward, for√ßando a cria√ß√£o de um commit de merge, utilizando a op√ß√£o --no-ff do comando git merge.

Mesclando altera√ß√µes com rebase
√Ä medida que uma aplica√ß√£o vai sendo desenvolvida, √© natural isolarmos
partes do trabalho em branches. E quando algo estiver pronto, ser√° feito um
merge do c√≥digo e, por isso, teremos um novo commit de merge.
Para projetos com muitas branches e muitos merges, o hist√≥rico do reposit√≥rio ficar√° repleto de commits de merge. Isso pode tornar bastante traba108

Casa do C√≥digo

Cap√≠tulo 6. Organizando o trabalho com branches

lhosas tarefas como revis√£o de c√≥digo.
H√° uma maneira alternativa de mesclar as altera√ß√µes de duas branches
que simplifica o hist√≥rico do projeto. Considerando que estamos na branch
master, em vez de utilizar git merge, √© poss√≠vel utilizar:
$ git rebase design

Na sa√≠da, deve aparecer algo como:
First, rewinding head to replay your work on top of it...
Applying: Alterando textos do banner

Pronto! Outra maneira de termos as mudan√ßas mescladas! A resposta do
comando git branch --no-merged seria vazia, j√° que n√£o h√° nenhuma
branch n√£o mesclada.
As mensagens anteriores informam que o reposit√≥rio foi rebobinado e
nosso trabalho refeito.
No nosso caso, o reposit√≥rio voltou ao estado que estava ao criarmos a
branch design a partir da master.
Depois disso, foi aplicado o commit que fizemos na branch design.
Finalmente, foi aplicado o nosso √∫ltimo commit na master, as altera√ß√µes
no texto dos banners.
Ao verificarmos o hist√≥rico do nosso reposit√≥rio com o comando git
log -n 3 --oneline --decorate --parents, ter√≠amos:
c05c05a 8f53065 (HEAD, master) Alterando textos do banner
8f53065 b92285b (design) Adicionando Bootstrap
b92285b a5b9fce Revert "Adicionando texto peculiar"

A branch design continua apontando para o commit que estava anteriormente.
J√° a branch master teve seu hist√≥rico refeito: foi criado um novo commit
com as altera√ß√µes no texto dos banners, com c√≥digo c05c05a.
Observe que o pai do novo commit c05c05a (Alterando textos do banner) √© o commit 8f53065 (Adicionando Bootstrap), que t√≠nhamos feito na
branch design.
109

6.7. Mesclando altera√ß√µes

Casa do C√≥digo

Perceba que n√£o houve commit de merge. O hist√≥rico de commits foi
linearizado.
Colocando o estado do nosso reposit√≥rio ap√≥s o rebase em um gr√°fico,
ter√≠amos:

Figura 6.10: Rebase de design na master

No caso de um fast-forward basta apontar a branch de destino para o
commit mais novo da branch sendo mesclada.
No nosso caso, se n√£o tiv√©ssemos nenhum novo commit na branch
master, a mesclagem seria feita apontando a master para o mesmo
commit para o qual a design aponta. Dessa forma, o rebase n√£o precisaria reescrever o hist√≥rico de commits.
Por isso, o git merge e o git rebase t√™m o mesmo efeito quando
h√° um fast-forward.

Mantendo o hist√≥rico da master intacto ap√≥s um rebase
Evitar ao m√°ximo altera√ß√µes no hist√≥rico da master √© uma pr√°tica bastante adotada por usu√°rios do Git.
Por√©m, nosso rebase anterior acabou deixando obsoleto o commit
2223859 (Alterando textos do banner), substituindo-o pelo commit
c05c05a, que tem o mesmo conte√∫do.

110

Casa do C√≥digo

Cap√≠tulo 6. Organizando o trabalho com branches

Poder√≠amos ter feito a integra√ß√£o das branches master e design com
rebase de maneira a deixar master intacta se tiv√©ssemos feito nosso trabalho
de uma maneira ligeiramente diferente.
Primeiramente, ter√≠amos que passar para a branch design com o comando git checkout design.
Ent√£o, far√≠amos o rebase da branch master na design com o comando
git rebase master.
Ap√≥s o rebase, o commit 8f53065 (Adicionando Bootstrap) da branch
design foi substitu√≠do, digamos, pelo commit de c√≥digo e887c10.
Visualizando graficamente nosso reposit√≥rio nesse momento, ter√≠amos:

Figura 6.11: Rebase de master na design

√â como se refiz√©ssemos o commit base da branch design, o commit da
branch master que √© ancestral do commit que fizemos em design (e de
todos que vir√£o).
Antes do rebase, o commit base era o de c√≥digo b92285b (Revert ‚ÄúAdicionando texto peculiar‚Äù).
Depois que o rebase foi executado, o commit base passou a ser o √∫ltimo
commit da master, de c√≥digo 2223859 (Alterando textos do banner).
O nome rebase vem da ideia de refazer o commit base de uma branch.
111

6.7. Mesclando altera√ß√µes

Casa do C√≥digo

Para isso, o Git precisa criar novos commits, mudando os ancestrais de commits anteriores.
Com a base da branch design refeita, √© poss√≠vel fazer um merge do tipo
fast-forward da design na branch master. Para tal, dever√≠amos ir para
a master executando git checkout master. Ent√£o, far√≠amos um git
merge design. O gr√°fico do reposit√≥rio ficaria parecido com:

Figura 6.12: Merge fast-forward de design na master, ap√≥s o rebase

Para saber mais: Qual usar? Um merge ou um rebase?
Utilizar merge mant√©m um registro fiel do que ocorreu com o nosso reposit√≥rio, mas os commits de merge complicam tarefas como navegar pelo
c√≥digo antigo e revisar c√≥digo novo.
J√° o rebase simplifica o hist√≥rico, mas perdemos informa√ß√£o sobre nosso
reposit√≥rio e alguns commits s√£o reescritos. No caso de conflitos, as coisas
podem ficar especialmente complicadas.
N√£o h√° uma resposta simples sobre a maneira ideal de mesclarmos altera√ß√µes com Git. Cada solu√ß√£o tem seus pr√≥s e contras.
Ao trabalharmos com branches remotas, nosso pr√≥ximo assunto, surgem
novas quest√µes.

112

Cap√≠tulo 7

Trabalhando em equipe com
branches remotas
Na dia a dia, dificilmente trabalhamos sozinhos. No cap√≠tulo 4 vimos como
trabalhar com reposit√≥rios remotos e no cap√≠tulo 5 vimos como utilizar o
GitHub, o que nos permite trabalhar em equipe de maneira consistente.
Trabalhar com branches, que vimos no cap√≠tulo 6, tamb√©m √© uma boa
maneira de organizar o trabalho em equipe. Mas quando trabalhamos com
reposit√≥rios remotos, surgem novas preocupa√ß√µes.

Lembrando dos reposit√≥rios remotos
No nosso reposit√≥rio local moveis, temos o remote origin que aponta
para o GitHub, o que podemos verificar com o comando git remote -v:
origin

git@github.com:fulanodasilva/moveis-ecologicos.git

7.1. Branches remotas

Casa do C√≥digo

(fetch)
origin git@github.com:fulanodasilva/moveis-ecologicos.git
(push)

O remote origin est√° apontando para um reposit√≥rio l√° do GitHub, que
tamb√©m tem sua branch master. Precisamos de uma maneira de receber e
enviar commits para a branch master do GitHub.

7.1

Branches remotas

No Git, temos branches remotas que apontam para branches que est√£o nos
reposit√≥rios remotos configurados.
Para diferenci√°-las das branches locais, o nome de uma branch remota
√© o nome do remote seguido do nome da branch. No nosso caso, a branch
master l√° do GitHub tem o nome de origin/master, j√° que o remote
origin aponta para o GitHub.
Ao contr√°rio de branches locais, que s√£o movidas a cada commit, branches remotas s√≥ s√£o movidas ao fazermos opera√ß√µes que envolvam comunica√ß√£o de rede como git push, git pull e tamb√©m o comando git
fetch, que veremos mais adiante. Portanto, uma branch remota representa
a situa√ß√£o da √∫ltima vez que houve comunica√ß√£o com o reposit√≥rio remoto.
Podemos listar as branches remotas passando a op√ß√£o -r para o comando
git branch:
$ git branch -r

Teremos na sa√≠da:
origin/master

Se quisermos mostrar tanto as branches locais como as remotas, podemos utilizar o comando git branch -a.
Para vermos para quais commits as branches remotas est√£o apontando,
podemos utilizar o comando anterior com a op√ß√£o -v:
114

Casa do C√≥digo

Cap√≠tulo 7. Trabalhando em equipe com branches remotas

$ git branch -r -v

Teremos:
origin/master b92285b Revert "Adicionando texto peculiar"

Observe que a branch origin/master est√° apontando o commit de
c√≥digo b92285b (Revert ‚ÄúAdicionando texto peculiar‚Äù).
Considerando que fizemos o merge da branch master com a branch
design no reposit√≥rio local no cap√≠tulo 6, ao executarmos o comando git
log -n 4 --oneline --decorate --parents, ter√≠amos:
e6b2f35 2223859 8f53065 (HEAD, master) Mesclando com a branch
design
2223859 b92285b Alterando textos do banner
8f53065 b92285b (design) Adicionando Bootstrap
b92285b a5b9fce (origin/master) Revert "Adicionando texto
peculiar"

Observe que a branch origin/master aponta para um commit anterior
√†s branches master e origin do reposit√≥rio local.
Exibindo gr√°ficos com o reposit√≥rio l√° do GitHub e o reposit√≥rio local,
cada um com suas branches, ficar√≠amos com algo parecido com:

Figura 7.1: O reposit√≥rio do GitHub n√£o cont√©m a branch design, apenas a sua
master

115

7.2. Compartilhando branches

Casa do C√≥digo

Figura 7.2: Reposit√≥rio local tem as branches locais master e design e a remota
origin/master

No fim das contas, tanto a branch master l√° do GitHub como a nossa
branch origin/master apontam para o commit de c√≥digo b92285b (Revert ‚ÄúAdicionando texto peculiar‚Äù).

7.2

Compartilhando branches

A branch design ainda n√£o existe l√° no GitHub. Para compartilh√°-la devemos informar os nomes do remote e da branch para o comando git push:
$ git push origin design

Dever√° aparecer uma resposta parecida com:
Counting objects: 5, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 669 bytes | 0 bytes/s, done.
Total 3 (delta 1), reused 0 (delta 0)
To git@github.com:fulanodasilva/moveis-ecologicos.git
* [new branch]
design -> design

O comando anterior envia para o remote origin os commits da branch
design.
116

Casa do C√≥digo

Cap√≠tulo 7. Trabalhando em equipe com branches remotas

Depois disso, podemos ver a branch design na p√°gina do nosso projeto
no GitHub.
Tamb√©m podemos ver um gr√°fico das branches do reposit√≥rio na
URL https://github.com/fulanodasilva/moveis-ecologicos/network (n√£o
esque√ßa de trocar fulanodasilva pelo seu usu√°rio.)
Nesse momento, se listarmos as branches remotas e locais com o comando
git branch -a -v, ter√≠amos:
design
8f53065 Adicionando Bootstrap
* master
e6b2f35 Mesclando com a branch design
remotes/origin/design 8f53065 Adicionando Bootstrap
remotes/origin/master b92285b Revert "Adicionando texto
peculiar"

Observe que temos as branches locais master e design e as branches
remotas origin/master e origin/design.
Como acabamos de fazer o git push da branch origin/design, essa
branch remota e a branch local design est√£o apontando para o commit de
c√≥digo 8f53065 (Adicionando Bootstrap).
J√° a branch local master e a remota origin/master est√£o apontando
para commits diferentes.
Colocando o estado atual dos nossos reposit√≥rios local e do GitHub em
gr√°ficos, ter√≠amos:

117

7.3. Obtendo novas branches remotas em outros reposit√≥rios

Casa do C√≥digo

Figura 7.3: Branch design no GitHub

Figura 7.4: Branch remota origin/design no reposit√≥rio moveis

7.3 Obtendo novas branches remotas em outros
reposit√≥rios
Para simular um outro membro do nosso time, vamos baixar o reposit√≥rio
em uma outra pasta.
Primeiramente, devemos voltar √† nossa pasta pessoal, executando cd ~.
118

Casa do C√≥digo

Ent√£o,
chamado

Cap√≠tulo 7. Trabalhando em equipe com branches remotas

vamos

clonar o reposit√≥rio em
outro,
executando o comando

um

diret√≥rio

git clone
git@github.com:fulanodasilva/moveis-ecologicos.git
outro.

Depois de clonar o reposit√≥rio, √© importante entrar no diret√≥rio, com o
comando cd outro.
Se listarmos as branches locais e remotas com o comando git branch
-a -v, teremos:
* master

b92285b Revert "Adicionando texto
peculiar"
remotes/origin/design 8f53065 Adicionando Bootstrap
remotes/origin/master b92285b Revert "Adicionando texto
peculiar"

Note que temos a branch local master e as remotas origin/master
e origin/design.
Por√©m, n√£o temos ainda uma branch local design. Se precisarmos trabalhar nessa branch no novo reposit√≥rio outro, precisamos executar o seguinte comando:
$ git checkout -b design origin/design

O comando apresentar√° na sa√≠da algo como:
Branch design set up to track remote branch design from origin
by rebasing.
Switched to a new branch ‚Äôdesign‚Äô

Com o comando anterior, fizemos um git checkout de uma nova
branch local chamada design a partir da branch remota origin/design.
Agora estamos prontos para trabalhar no design da aplica√ß√£o, se quisermos.
Branches locais criadas a partir de branches remotas s√£o chamadas de
tracking branches.
Se executarmos git branch -a -v novamente, teremos:

119

7.3. Obtendo novas branches remotas em outros reposit√≥rios

Casa do C√≥digo

* design
master

8f53065 Adicionando Bootstrap
b92285b Revert "Adicionando texto
peculiar"
remotes/origin/design 8f53065 Adicionando Bootstrap
remotes/origin/master b92285b Revert "Adicionando texto
peculiar"

Uma outra maneira, mais sucinta, de criar uma tracking branch √© utilizar a op√ß√£o -t do comando git checkout.
No nosso caso, far√≠amos git checkout -t origin/design.
Seria criada localmente a tracking branch design relacionada com a
branch remota origin/design.
Depois de criada a tracking branch design no reposit√≥rio outro, os
reposit√≥rios moveis e o do GitHub estariam inalterados.
Se visualizarmos o reposit√≥rio outro, ter√≠amos:

Figura 7.5: Tracking branch design no reposit√≥rio outro

120

Casa do C√≥digo

7.4

Cap√≠tulo 7. Trabalhando em equipe com branches remotas

Enviando commits para o reposit√≥rio central

Vamos voltar para nosso diret√≥rio moveis, executando o comando cd
~/moveis.
Nosso reposit√≥rio moveis est√° dois commits na frente da branch remota
origin/master.
Podemos verificar isso executando git status:
On branch master
Your branch is ahead of ‚Äôorigin/master‚Äô by 2 commits.
(use "git push" to publish your local commits)
nothing to commit, working directory clean

Se executarmos, git log -n 4 --oneline --decorate, teremos:
e6b2f35
2223859
8f53065
b92285b

(HEAD, master) Mesclando com a branch design
Alterando textos do banner
(origin/design, design) Adicionando Bootstrap
(origin/master) Revert "Adicionando texto peculiar"

Ent√£o, para enviar as altera√ß√µes na branch master para o reposit√≥rio
remoto, devemos fazer:
$ git push origin master

Teremos como resposta algo como:
Counting objects: 10, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (5/5), done.
Writing objects: 100% (6/6), 670 bytes | 0 bytes/s, done.
Total 6 (delta 3), reused 0 (delta 0)
To git@github.com:fulanodasilva/moveis-ecologicos.git
b92285b..e6b2f35 master -> master

Depois disso, a branch master e a origin/master estar√£o apontando
para o commit de merge e6b2f35 (Mesclando com a branch design). √â
poss√≠vel nos certificarmos disso, executando git log -n 4 --oneline
--decorate novamente. Ter√≠amos:
121

7.4. Enviando commits para o reposit√≥rio central

Casa do C√≥digo

e6b2f35 (HEAD, origin/master, master) Mesclando com a branch
design
2223859 Alterando textos do banner
8f53065 (origin/design, design) Adicionando Bootstrap
b92285b Revert "Adicionando texto peculiar"

J√° no reposit√≥rio outro, a branch master ainda continua apontando
para o commit b92285b (Revert ‚ÄúAdicionando texto peculiar‚Äù) e a branch
design continua apontando para o commit 8f53065 (Adicionando Bootstrap).
O reposit√≥rio outro n√£o sofreu altera√ß√µes. J√° uma visualiza√ß√£o do estados do reposit√≥rios moveis e do GitHub seria:

Figura 7.6: Commits de moveis foram recebidos pelo reposit√≥rio do GitHub

122

Casa do C√≥digo

Cap√≠tulo 7. Trabalhando em equipe com branches remotas

Figura 7.7: Branch origin/master foi atualizada no reposit√≥rio moveis

7.5

Obtendo commits de uma branch remota

Um novo commit
Digamos que outro desenvolvedor da nossa equipe esteja trabalhando em
uma p√°gina que lista m√≥veis feitos a partir de garrafas PET. Todo trabalho
est√° sendo feito diretamente na branch master.
Para simular esse outro desenvolvedor, vamos utilizar nosso reposit√≥rio outro. Retornaremos a esse reposit√≥rio, executando o comando cd
~/outro.
Ent√£o, vamos nos certificar que estamos na branch master, executando
git checkout master.
Feito isso, vamos criar um arquivo moveis_pet.html com o seguinte
conte√∫do:
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<meta name="description"
content="M√≥veis ecol√≥gicos PET">

123

7.5. Obtendo commits de uma branch remota

Casa do C√≥digo

<meta name="keywords" content="moveis ecologicos pet">
<link rel="stylesheet" href="principal.css">
<title>M√≥veis Ecol√≥gicos de garrafas PET</title>
</head>
<body>
<h1>M√≥veis Ecol√≥gicos S. A.</h1>
<h2>M√≥veis de Garrafas PET</h2>
<p>Funcionais, baratos e amigos do meio ambiente.</p>
<ul>
<li>Sof√°s</li>
<li>Racks</li>
<li>Cadeiras</li>
<li>Mesas</li>
</ul>
</body>
</html>

Com o arquivo moveis_pet.html criado, vamos rastre√°-lo com git
add moveis_pet.html e grav√°-lo no reposit√≥rio com git commit -m
"Adicionando p√°gina sobre m√≥veis PET".
Se mostramos o hist√≥rico do reposit√≥rio nesse ponto com git log -n
2 --oneline --decorate, ter√≠amos:
e1b10ff (HEAD, master) Adicionando p√°gina sobre m√≥veis PET
b92285b (origin/master) Revert "Adicionando texto peculiar"

Repare que a branch origin/master do reposit√≥rio outro est√° no
commit b92285b (Revert ‚ÄúAdicionando texto peculiar‚Äù), apesar da branch
master l√° do GitHub estar alguns commits na frente, no commit e6b2f35
(Mesclando com a branch design).
O reposit√≥rio moveis e o do GitHub continuaram iguais. J√° se visualizarmos o estado do reposit√≥rio outro ap√≥s o commit, ter√≠amos:

124

Casa do C√≥digo

Cap√≠tulo 7. Trabalhando em equipe com branches remotas

Figura 7.8: Branch master do reposit√≥rio outro apontando para o novo commit

Trazendo commits de um reposit√≥rio remoto com fetch
Para obtermos os commits da branch remota origin/master no nosso
reposit√≥rio outro, podemos executar o comando:
$ git fetch origin

Teremos como resposta algo como:
remote: Counting objects: 6, done.
remote: Compressing objects: 100% (5/5), done.
remote: Total 6 (delta 1), reused 0 (delta 0)
Unpacking objects: 100% (6/6), done.
From github.com:fulanodasilva/moveis-ecologicos
b92285b..e6b2f35 master
-> origin/master

Com o comando git fetch, trazemos os commits de uma branch remota que ainda n√£o estavam presentes localmente.
No nosso caso, obtemos os commits 2223859 (Alterando textos do banner) e e6b2f35 (Mesclando com a branch design) que estavam l√° no GitHub
mas ainda n√£o estavam na branch origin/master.
125

7.5. Obtendo commits de uma branch remota

Casa do C√≥digo

Por√©m, os novos commits da branch remota origin/master ainda n√£o
foram aplicados na branch local master, o que podemos constatar executando o comando git branch -a -v:
design
* master

8f53065 Adicionando Bootstrap
e1b10ff Adicionando p√°gina sobre m√≥veis
PET
remotes/origin/design 8f53065 Adicionando Bootstrap
remotes/origin/master e6b2f35 Mesclando com a branch design

Observe que a branch master ainda continua apontando para o commit e1b10ff (Adicionando p√°gina sobre m√≥veis PET). √â importante notar
que os novos commits ainda n√£o foram aplicados ap√≥s executarmos o git
fetch.
Depois de obter os commits da branch origin/master, o gr√°fico do
reposit√≥rio outro ficaria:

Figura 7.9: Commits remotos obtidos na branch origin/master de outro

126

Casa do C√≥digo

Cap√≠tulo 7. Trabalhando em equipe com branches remotas

7.6 Mesclando branches remotas e locais
Mesclando branches remotas e locais com merge
No reposit√≥rio

outro, temos alguns commits na branch remota
origin/master que ainda n√£o foram aplicados na branch master.

Como fazer para mesclar as duas branches? Ser√° que mesclar uma branch
remota a uma local precisa de algum comando especial?
N√£o! Basta usarmos uma das duas maneiras de mesclar branches no Git:
um merge ou um rebase.
Se escolhermos fazer um merge e estivermos na branch master, basta
executarmos:
$ git merge origin/master -m "Mesclando origin/master em master"

Se n√£o informarmos uma mensagem para o commit de merge, ser√°
aberto um editor de texto.
Na sa√≠da, ter√≠amos:
Removing principal.css
Merge made by the ‚Äôrecursive‚Äô strategy.
index.html
| 29 +++++++++++++++++++++-------js/principal.js | 2 +principal.css
| 11 ----------3 files changed, 22 insertions(+), 20 deletions(-)
delete mode 100111 principal.css

Pronto! J√° temos as mudan√ßas l√° do GitHub aplicadas na branch local
master do reposit√≥rio outro.
Se
executarmos
git log -n 6 --oneline --decorate
--parents, teremos:
550e27d e1b10ff e6b2f35 (HEAD, master) Mesclando origin/master
em master
e1b10ff b92285b Adicionando p√°gina sobre m√≥veis PET

127

7.6. Mesclando branches remotas e locais

Casa do C√≥digo

e6b2f35 2223859 8f53065 (origin/master) Mesclando com a branch
design
2223859 b92285b Alterando textos do banner
8f53065 b92285b (origin/design, design) Adicionando Bootstrap
b92285b a5b9fce Revert "Adicionando texto peculiar"

Se n√£o houvesse nenhum novo commit na branch local master do
reposit√≥rio outro, a master teria um fast-forward, sendo simplesmente movida para apontar para o mesmo commit da branch remota
origin/master.
Nenhuma altera√ß√£o teria acontecido no reposit√≥rio moveis e do GitHub.
Agora, um gr√°fico do hist√≥rico anterior do reposit√≥rio outro seria:

Figura 7.10: Merge de origin/master na branch master do reposit√≥rio outro

Mesclando branches remotas e locais com rebase
A alternativa ao merge seria um rebase da branch origin/master na
128

Casa do C√≥digo

Cap√≠tulo 7. Trabalhando em equipe com branches remotas

branch master. Para isso, devemos executar:
$ git rebase origin/master

Ter√≠amos como resposta:
First, rewinding head to replay your work on top of it...
Applying: Adicionando p√°gina sobre m√≥veis PET

As mudan√ßas l√° do GitHub foram aplicadas na branch local master do
reposit√≥rio outro, mas n√£o houve commit de merge.
O hist√≥rico do reposit√≥rio foi linearizado, o que podemos observar executando git log -n 5 --oneline --decorate --parents:
0f8d4b3 e6b2f35 (HEAD, master) Adicionando p√°gina sobre m√≥veis
PET
e6b2f35 2223859 8f53065 (origin/master) Mesclando com a branch
design
2223859 b92285b Alterando textos do banner
8f53065 b92285b (origin/design, design) Adicionando Bootstrap
b92285b a5b9fce Revert "Adicionando texto peculiar"

Observe que o commit com mensagem ‚ÄúAdicionando p√°gina sobre m√≥veis PET‚Äù foi refeito, ficando com o c√≥digo 0f8d4b3, ap√≥s serem aplicados
os commits de origin/master.
Em geral, n√£o queremos alterar o hist√≥rico de commits da branch local master. Mas √© mais importante ainda evitar mudan√ßas nos commits
da branch remota origin/master, que √© compartilhada por todos os
membros da nossa equipe.
Uma alternativa bastante utilizada √© n√£o comitar diretamente na
branch local master, mas em uma outra branch local espec√≠fica para
a funcionalidade sendo desenvolvida. Ent√£o, far√≠amos o rebase da
origin/master nessa outra branch local, que teria seu hist√≥rico modificado. Dessa forma, a master ficaria intacta.
Ao final da funcionalidade, a branch local da funcionalidade teria um
merge feito na branch local master.
129

7.6. Mesclando branches remotas e locais

Casa do C√≥digo

O reposit√≥rio moveis e o do GitHub n√£o sofreram mudan√ßas. Visualizando a situa√ß√£o do reposit√≥rio outro, ter√≠amos:

Figura 7.11: Rebase de origin/master na branch master do reposit√≥rio outro

Obtendo commits e mesclando de uma vez com pull
Para obtermos e mesclarmos os novos commits de uma branch remota
com uma branch local poder√≠amos ter usado um comando s√≥:
$ git pull

Ser√° aberto um editor de texto para que seja informada a mensagem do
commit de merge.
Na sa√≠da, teremos algo como:
remote: Counting objects: 6, done.
remote: Compressing objects: 100% (5/5), done.
Unpacking objects: 100% (6/6), done.
remote: Total 6 (delta 1), reused 0 (delta 0)
From github.com:fulanodasilva/moveis-ecologicos
b92285b..e6b2f35 master
-> origin/master
Removing principal.css
Merge made by the ‚Äôrecursive‚Äô strategy.
index.html
| 29 +++++++++++++++++++++-------js/principal.js | 2 +-

130

Casa do C√≥digo

Cap√≠tulo 7. Trabalhando em equipe com branches remotas

principal.css
| 11 ----------3 files changed, 22 insertions(+), 20 deletions(-)
delete mode 100111 principal.css

O comando anterior vai ter o mesmo efeito de um git fetch origin
seguido de um git merge origin/master.
Se desej√°ssemos que o git pull tivesse um efeito parecido com git
fetch origin seguido de um git rebase origin/master, poder√≠amos ter passado a op√ß√£o --rebase:
$ git pull --rebase

Ter√≠amos como resposta:
remote: Counting objects: 6, done.
remote: Compressing objects: 100% (5/5), done.
remote: Total 6 (delta 1), reused 0 (delta 0)
Unpacking objects: 100% (6/6), done.
From github.com:fulanodasilva/moveis-ecologicos
b92285b..e6b2f35 master
-> origin/master
First, rewinding head to replay your work on top of it...
Applying: Adicionando p√°gina sobre m√≥veis PET

Para saber mais: Qual usar? Um pull ou um pull --rebase?
Usar git pull ou git pull --rebase ao mesclar com mudan√ßas
remotas √© uma quest√£o parecida com a de se devemos usar git merge ou
git rebase para mesclagens locais.
O comando git pull, n√£o passa de um git fetch seguido de um
git merge. Por isso, temos as mesmas vantagens e desvantagens do merge,
mas agora considerando reposit√≥rios remotos. Como vantagem, temos um
registro fiel do que aconteceu em cada reposit√≥rio da nossa equipe, com os
commits exatos. Mas, como desvantagem, os v√°rios commits de merge complicam o entendimento do hist√≥rico do projeto, afetando tarefas como navegar por c√≥digo antigo e revisar c√≥digo novo. Em times grandes, um hist√≥rico
complicado pode tornar o trabalho bastante desafiador.
Na figura a seguir, h√° um pequeno trecho do hist√≥rico de um projeto real
em que um dos autores trabalharam, com detalhes omitidos. Fica clara a confus√£o ocasionada pelos commits de merge:
131

7.6. Mesclando branches remotas e locais

Casa do C√≥digo

Figura 7.12: Commits de merge em um projeto real

J√° o comando git pull --rebase √© um git fetch seguido de um
git rebase. O hist√≥rico √© linearizado, simplificando nosso trabalho. Por√©m, a cada rebase alguns commits s√£o reescritos e, no fim das contas, estamos
perdendo informa√ß√µes sobre nosso reposit√≥rio. Quando acontecem conflitos,
corrigi-los pode ser bastante complicado.
O rebase pode ser especialmente problem√°tico se acabarmos mudando
um commit j√° compartilhado com outros membros da nossa equipe. Nossos
colegas podem sofrer na hora de obter os commits modificados, j√° que o Git
pode se perder.
N√£o parece uma boa solu√ß√£o usar sempre o merge ou sempre o rebase.
Um meio termo parece algo mais sensato!
Nossa sugest√£o √© a seguinte:
‚Ä¢ Utilizar um git pull --rebase para obter mudan√ßas remotas. √â
uma pr√°tica segura porque nossos novos commits locais ainda n√£o foram compartilhados, ou seja, outros membros nem sabem da exist√™ncia
desses commits. Por isso, alter√°-los n√£o traz grandes problemas.
‚Ä¢ Ao trabalharmos em uma nova funcionalidade utilizando uma branch,
marcamos sua entrega fazendo um merge. Assim, conseguimos ter
uma boa ideia de quando a funcionalidade come√ßou a ser desenvolvida
e quando foi reintegrada √† branch master.
132

Casa do C√≥digo

Cap√≠tulo 7. Trabalhando em equipe com branches remotas

‚Ä¢ Se estivermos trabalhando sozinhos na nova funcionalidade, podemos
fazer rebases peri√≥dicos da master na nossa branch para obter c√≥digo
novo, por√©m deixando o hist√≥rico da branch bem limpo.
‚Ä¢ √â interessante fazer o push da nossa branch solit√°ria em um reposit√≥rio
remoto, para backup. Mas √© importante evitar que algu√©m fa√ßa checkout.
Uma discuss√£o detalhada pode ser encontrada em:
sourcetreeapp.com/2012/08/21/merge-or-rebase/

http://blog.

7.7 Deletando branches remotas
Vamos dizer que nosso cliente solicitou que fiz√©ssemos uma p√°gina de contatos que permite ao usu√°rio do site envio de mensagens.
Para implementar essa solicita√ß√£o, trabalharemos em uma nova branch
chamada contato. Para cri√°-la e j√° come√ßar a trabalhar nela, executamos o
comando git checkout -b contato. Ter√≠amos como resposta:
Switched to a new branch ‚Äôcontato‚Äô

Ent√£o, vamos iniciar o desenvolvimento criando um arquivo com o nome
contato.html e com o seguinte c√≥digo:
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>Entre em contato conosco</title>
</head>
<body>
<h1>Fale com a gente.</h1>
<p>D√∫vidas, sugest√µes ou choramingos</p>
<form>
<label for="nome">Nome</label>
<input id="nome">
<label for="email">Email</label>
<input id="email">

133

7.7. Deletando branches remotas

Casa do C√≥digo

<label for="mensagem">Mensagem</label>
<textarea id="mensagem"></textarea>
<input type="submit" value="Enviar">
</form>
</body>
</html>

Vamos rastrear nosso novo arquivo com git add contato.html e
comit√°-lo com git commit -m "Iniciando p√°gina de contato".
Mas surgiu uma nova demanda urgente! Temos que parar de trabalhar
na p√°gina de contato. Algu√©m do nosso time disse que iria dar seguimento.
Por isso, resolvemos compartilhar nossa branch executando: git push
origin contato.
Pronto, a branch contato foi publicada e tem uma c√≥pia l√° no GitHub.
Ao executarmos o comando git branch -a -v, ter√≠amos:
* contato
design
master

3523c62 Iniciando p√°gina de contato
8f53065 Adicionando Bootstrap
0f8d4b3 Adicionando p√°gina sobre m√≥veis
PET
remotes/origin/contato 3523c62 Iniciando p√°gina de contato
remotes/origin/design 8f53065 Adicionando Bootstrap
remotes/origin/master 0f8d4b3 Adicionando p√°gina sobre m√≥veis
PET

Mas nosso cliente, que √© um pouco indeciso, voltou atr√°s e quis simplificar
o projeto, parando o desenvolvimento da p√°gina de contato e deixando apenas
o e-mail na p√°gina principal.
Devido a essa mudan√ßa nos requisitos, resolvemos remover nossa branch
contato mudando para a branch master do nosso reposit√≥rio e executando o comando git branch -D contato.
Mas quando executamos o comando anterior, removemos apenas a
branch local contato. L√° no GitHub, a branch contato continua intacta.
E a nossa branch remota origin/contato, que aponta para a branch correspondente do GitHub, tamb√©m continua no nosso reposit√≥rio.
Podemos constatar isso executando novamente o comando git branch
-a -v:
134

Casa do C√≥digo

Cap√≠tulo 7. Trabalhando em equipe com branches remotas

design
* master

8f53065 Adicionando Bootstrap
0f8d4b3 Adicionando p√°gina sobre m√≥veis
PET
remotes/origin/contato 3523c62 Iniciando p√°gina de contato
remotes/origin/design 8f53065 Adicionando Bootstrap
remotes/origin/master 0f8d4b3 Adicionando p√°gina sobre m√≥veis
PET

Para removermos definitivamente a branch remota origin/contato e
a branch contato l√° do GitHub, devemos executar:
$ git push origin :contato

Ter√≠amos na sa√≠da:
To git@github.com:fulanodasilva/moveis-ecologicos.git
- [deleted]
contato

Pronto! Se olharmos no GitHub, a branch contato n√£o aparece mais!

No caso da branch l√° do servidor ter um nome diferente da branch
local, ao delet√°-la devemos utilizar o nome da branch do servidor.
Por
exemplo,
se
a
branch
do
servidor
fosse
contato_do_servidor, dever√≠amos executar git push origin
:contato_do_servidor.

135

Cap√≠tulo 8

Controlando vers√µes do c√≥digo
com tags
Mostramos o novo design para o nosso cliente e foi um sucesso! Nosso cliente
pediu que coloc√°ssemos no ar a nova vers√£o, o mais r√°pido poss√≠vel.
Ao liberarmos essa nova vers√£o do site para implanta√ß√£o em produ√ß√£o, √©
uma boa pr√°tica tirarmos uma foto do c√≥digo nesse momento. Se houver algum erro, saberemos exatamente o c√≥digo que est√° sendo usado em produ√ß√£o
e ser√° mais f√°cil ca√ßar a origem da falha.
Em sistemas de controle de vers√£o, essas fotos de um determinado instante de um reposit√≥rio s√£o chamadas de tags.
No Git, uma tag √© simplesmente um apontador fixo para um commit espec√≠fico. Ao contr√°rio de branches, esse apontador n√£o avan√ßa com novos
commits.

8.1. Criando, listando e deletando tags

Casa do C√≥digo

Em geral, criamos tags com nomes como v1.0, v1.1, v2.0 e assim
por diante. Cada equipe deve definir o seu padr√£o.
Os nomes permitidos para tags e branches t√™m algumas restri√ß√µes:
n√£o podem conter alguns caracteres especiais como ~, ^ e :, al√©m de
sequ√™ncias de caracteres como .. e @{.
Os detalhes podem ser obtidos em: http://git-scm.com/docs/
git-check-ref-format.html

8.1

Criando, listando e deletando tags

Para criarmos uma tag v1.0 no Git, devemos executar o comando:
$ git tag v1.0

O gr√°fico do nosso reposit√≥rio local outro depois do comando anterior
ficaria parecido com:

Figura 8.1: Nova tag no reposit√≥rio outro

Se quisermos listar as tags do nosso reposit√≥rio, basta executarmos:
$ git tag

Ter√≠amos como resposta:
138

Casa do C√≥digo

Cap√≠tulo 8. Controlando vers√µes do c√≥digo com tags

v1.0

Se verificarmos o hist√≥rico do reposit√≥rio com o comando git log -n
5 --oneline --decorate, veremos:
0f8d4b3 (HEAD, tag: v1.0, master) Adicionando p√°gina sobre
m√≥veis PET
e6b2f35 (origin/master) Mesclando com a branch design
2223859 Alterando textos do banner
8f53065 (origin/design, design) Adicionando Bootstrap
b92285b Revert "Adicionando texto peculiar"

Observe que o commit 0f8d4b3 possui a tag v1.0.
Podemos criar uma tag para um commit passado. Se quisermos criar uma
tag chamada banners para o commit 2223859 (Alterando textos do banner), devemos executar:
$ git tag banners 2223859

Imagine que tenhamos errado o nome de uma tag. Por exemplo, criamos
a tag verssao1 com o comando git tag verssao1. Podemos delet√°-la
com o comando:
$ git tag -d verssao1

Na sa√≠da, teremos:
Deleted tag ‚Äôverssao1‚Äô (was 0f8d4b3)

8.2 Mais informa√ß√µes com tags anotadas
As tags que acabamos de criar s√£o chamadas de tags leves, porque n√£o passam
de um simples apontador fixo para um commit.
Se desejarmos manter mais informa√ß√µes como quando uma tag foi criada,
quem a criou, al√©m de termos uma mensagem descritiva, devemos criar tags
anotadas.
Para criarmos uma tag anotada, basta usarmos a op√ß√£o -a do comando
git tag e informar uma mensagem com a op√ß√£o -m:
139

8.3. Compartilhando tags com a sua equipe

Casa do C√≥digo

$ git tag -a v1.1 -m "Liberando vers√£o urgente"

Se n√£o informarmos uma mensagem ao utilizarmos a op√ß√£o -a do
comando git tag, ser√° aberto um editor de texto.
Podemos exibir as informa√ß√µes de uma tag anotada com o comando:
$ git show -s v1.1

Ter√≠amos como resposta detalhes sobre a cria√ß√£o da tag anotada, al√©m de
informa√ß√µes sobre o commit para o qual a tag aponta:
tag v1.1
Tagger: Fulano da Silva <fulanodasilva.git@gmail.com>
Date:
Sun Jun 22 13:49:13 2014 -0300
Liberando vers√£o urgente
commit 0f8d4b3000000000000000000000000000000000
Author: Fulano da Silva <fulanodasilva.git@gmail.com>
Date:
Fri Jun 13 17:14:16 2014 -0300
Adicionando p√°gina sobre m√≥veis PET

O comando git show n√£o serve apenas para exibir informa√ß√µes de
tags.
√â poss√≠vel utiliz√°-lo para inspecionar commits e outros detalhes internos do Git.

8.3 Compartilhando tags com a sua equipe
As tags criadas com o comando git tag, anotadas ou n√£o, ficam dispon√≠veis
apenas no reposit√≥rio local.
Quando estamos trabalhando em equipe, em geral queremos compartilhar as tags que criamos com nossos colegas, enviando-as para o reposit√≥rio
do servidor. No nosso caso, enviar√≠amos as tags que criamos para o GitHub.
140

Casa do C√≥digo

Cap√≠tulo 8. Controlando vers√µes do c√≥digo com tags

Para compartilhar tags, fazemos de maneira parecida com o que fizemos
com branches, utilizando o comando git push. Para compartilhar a tag
v1.0, devemos executar o comando:
$ git push origin v1.0

Ser√° exibido algo como:
Counting objects: 13, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (8/8), done.
Writing objects: 100% (9/9), 1.20 KiB | 0 bytes/s, done.
Total 9 (delta 4), reused 0 (delta 0)
To git@github.com:fulanodasilva/moveis.git
* [new tag]
v1.0 -> v1.0

Pronto! A tag v1.0 foi enviada para o reposit√≥rio remoto origin. Nossos colegas de equipe poder√£o obter essa tag quando executarem o comando
git pull.
Mas ainda temos outras tags para compartilhar: as tags banners e v1.1.
Executar o comando git push para cada tag √© algo bastante tedioso.
Se quisermos enviar todas as novas tags do reposit√≥rio local para um
reposit√≥rio remoto podemos utilizar o comando git push com a op√ß√£o
--tags:
$ git push origin --tags

Na sa√≠da, teremos:
Counting objects: 1, done.
Writing objects: 100% (1/1), 181 bytes | 0 bytes/s, done.
Total 1 (delta 0), reused 0 (delta 0)
To git@github.com:fulanodasilva/moveis.git
* [new tag]
banners -> banners
* [new tag]
v1.1 -> v1.1

Se olharmos no GitHub, veremos que nossas tags est√£o l√°!

141

Cap√≠tulo 9

Lidando com conflitos
Ao mesclarmos mudan√ßas entre duas branches locais no cap√≠tulo 6 e entre
uma branch local e uma remota no cap√≠tulo 7, o Git soube fazer essa mesclagem automaticamente, sem qualquer problema.
Comparado com outros sistemas de controles de vers√£o, o Git √© especialmente bom ao juntar mudan√ßas de duas branches diferentes.
Nos cap√≠tulos anteriores, fizemos mudan√ßas em arquivos diferentes, o que
o Git resolve com facilidade. At√© mudan√ßas em um mesmo arquivo podem
ser resolvidas.
Mas mesmo o Git n√£o consegue fazer milagres!

9.1. Mesclando mudan√ßas em um mesmo arquivo sem conflitos

Casa do C√≥digo

9.1 Mesclando mudan√ßas em um mesmo arquivo
sem conflitos
Nosso cliente ligou desesperado dizendo que descobriu um erro importante
no site: estava faltando o acr√¥nimo ‚ÄúS. A.‚Äù no t√≠tulo da p√°gina.
Precisando atend√™-lo com urg√™ncia, fizemos a seguinte modifica√ß√£o na
branch master, no arquivo index.html:
<!-- in√≠cio do arquivo ... -->
<head>
<!-- tags meta e link ... -->
<title>M√≥veis Ecol√≥gicos S. A.</title>
<!-- tag script -->
</head>
<!-- restante do arquivo ... -->

Com a altera√ß√£o feita, comitamos o arquivo index.html com o comando git commit -am "Corrigindo t√≠tulo da p√°gina". Obtivemos na sa√≠da:
[master 1963258] Corrigindo t√≠tulo da p√°gina
1 file changed, 1 insertion(+), 1 deletion(-)

Outra coisa que nosso cliente nos informou √© que a p√°gina da M√≥veis
Ecol√≥gicos S. A. estava sendo copiada por outras empresas do ramo.
Sugerimos algumas solu√ß√µes para minimizar o problema mas nosso cliente decidiu por uma maneira simples: colocar um rodap√© na p√°gina com o
s√≠mbolo de copyright. Mas o rodap√© teria que ser bonito, ‚Äúo rodap√© mais belo
de todos os tempos‚Äù, segundo nosso cliente.
Para podermos trabalhar com calma em busca do rodap√© perfeito, passando a trabalhar na branch design depois de executar o comando git
checkout design.
Depois de algum esfor√ßo chegamos a um design utilizando classes do framework CSS Bootstrap. Modificamos o arquivo index.html conforme a
seguir:
<!-- inicio do arquivo -->
<p class="text-muted text-right">

144

Casa do C√≥digo

Cap√≠tulo 9. Lidando com conflitos

&copy; Copyright M√≥veis Ecol√≥gicos S. A.
</p>
<div>
</body>
</html>

Ent√£o, adicionamos a mudan√ßa e a gravamos no reposit√≥rio com o comando git commit -am "Adicionando rodap√© com copyright".
Na sa√≠da, foi mostrado:
[design 0e2d613] Adicionando rodap√© com copyright
1 file changed, 3 insertions(+)

Listando o hist√≥rico dos √∫ltimos dois commits com o comando git log
-n 2 --oneline --decorate --all, ter√≠amos:
0e2d613 (HEAD, design) Adicionando rodap√© com copyright
1963258 (master) Corrigindo t√≠tulo da p√°gina

O commit de c√≥digo 0e2d613 (Adicionando rodap√© com copyright)
ainda n√£o foi mesclado na master.
Vamos voltar para a branch master executando o comando git
checkout master.
Agora, vamos fazer o merge da branch design na master com o
comando git merge design -m "Merge de design na master".
Teremos como resposta:
Auto-merging index.html
Merge made by the ‚Äôrecursive‚Äô strategy.
index.html | 3 +++
1 file changed, 3 insertions(+)

Se observarmos o conte√∫do do arquivo index.html, o conte√∫do est√°
de acordo com as √∫ltimas altera√ß√µes: o t√≠tulo da p√°gina foi atualizado e foi
inserido um rodap√© com informa√ß√µes de copyright.
O Git conseguiu fazer o merge autom√°tico, mesclando sem problemas
altera√ß√µes no arquivo index.html das branches design e master. Isso
aconteceu porque alteramos o arquivo em √°reas distintas.
145

9.2. Conflitos ap√≥s um merge com mudan√ßas em um mesmo arquivo

Casa do C√≥digo

Se tiv√©ssemos feito um git rebase design para mesclar as altera√ß√µes da branch design na master, tamb√©m n√£o ter√≠amos nenhum
conflito.
No caso das altera√ß√µes serem feitas em uma branch remota, poder√≠amos utilizar um git pull ou um git pull --rebase sem nenhum
conflito.

9.2 Conflitos ap√≥s um merge com mudan√ßas em
um mesmo arquivo
Deixamos nosso cliente satisfeito. E com a satisfa√ß√£o surgiram novas ideias!
Uma das coisas que nosso cliente pediu foi colocar um texto bastante criativo no topo da p√°gina. E solicitou que a mudan√ßa fosse urgente!
Por isso, na branch master, editamos o arquivo index.html inserindo
logo abaixo da tag h2 o seguinte par√°grafo:
<!-- inicio do arquivo at√© tag h2-->
<p>Do lixo ao luxo, um resgate do descartado e uma transforma√ß√£o
em algo funcional. Reaproveitar √© aproveitar. Coisas descartadas
s√£o nossa carta na manga. Erodido, mas √∫nico.</p>
<!-- ul e restante do arquivo -->

Na branch master, comitamos as altera√ß√µes no index.html
executando o comando
git commit -am "Adicionando texto
criativo". Temos como resposta:
[master 9333339] Adicionando texto criativo
1 file changed, 3 insertions(+)

Outro pedido do nosso cliente foi melhorar o design do banner, de maneira a destac√°-los.
Para trabalhar nessa demanda, mudamos para a branch design executando o comando git checkout design.
Pesquisamos um pouco e resolvemos utilizar um recurso do Bootstrap para embelezar o banner. Na branch design, editamos o arquivo
index.html, inserindo as seguintes classes CSS na tag h2:
146

Casa do C√≥digo

Cap√≠tulo 9. Lidando com conflitos

<!-- inicio do arquivo at√© tag h1-->
<h2 id="mensagem" class="alert alert-info"></h2>
<!-- ul e restante do arquivo -->

Depois disso, na branch design, comitamos as altera√ß√µes no arquivo
index.html executando o comando git commit -am "Melhorando
design do banner". Na sa√≠da, tivemos:
[design 5555222] Melhorando design do banner
1 file changed, 1 insertion(+), 1 deletion(-)

Ainda na branch design, ao exibirmos o hist√≥rico dos √∫ltimos dois
commits do reposit√≥rio com o comando git log -n 2 --oneline
--decorate --all, ter√≠amos:
5555222 (HEAD, design) Melhorando design do banner
9333339 (master) Adicionando texto criativo

Note que o commit de c√≥digo 5555222 (Melhorando design do banner)
ainda n√£o teve suas altera√ß√µes aplicadas na branch master.
Executando o comando git checkout master, voltamos a trabalhar
na branch master.
Para mesclarmos o √∫ltimo commit da branch design na master, executamos o comando git merge design -m "Merge de design na
master". Na sa√≠da, teremos:
Auto-merging index.html
CONFLICT (content): Merge conflict in index.html
Automatic merge failed;fix conflicts and then commit the result.

Observe a mensagem anterior: foi indicado que houve um conflito no
arquivo index.html e que o merge autom√°tico falhou.
Se abrirmos o arquivo index.html veremos um conte√∫do estranho:
<!-- inicio do arquivo arquivo at√© h1 -->
<<<<<<< HEAD
<h2 id="mensagem"></h2>
<p>Do lixo ao luxo, um resgate do descartado e uma transforma√ß√£o

147

9.2. Conflitos ap√≥s um merge com mudan√ßas em um mesmo arquivo

Casa do C√≥digo

em algo funcional. Reaproveitar √© aproveitar. Coisas descartadas
s√£o nossa carta na manga. Erodido, mas √∫nico.</p>
=======
<h2 id="mensagem" class="alert alert-info"></h2>
>>>>>>> design
<!-- ul e restante do arquivo -->

Mesmo sendo muito bom para fazer o merge autom√°tico, dessa vez o Git
n√£o conseguiu mesclar o arquivo index.html de maneira clara porque foram feitas altera√ß√µes na mesma regi√£o do arquivo.
De forma cautelosa, o Git marcou um conflito com os caracteres <, = e
>.
Entre os textos <<<<<<< HEAD e ======= est√£o as altera√ß√µes que fizemos na branch master, que √© a branch atual, para qual o HEAD est√° apontando.
J√° entre ======= e >>>>>>> design, est√£o as altera√ß√µes que fizemos
na branch design.
Ao executarmos git status, teremos:
On branch master
Your branch is ahead of ‚Äôorigin/master‚Äô by 5 commits.
(use "git push" to publish your local commits)
You have unmerged paths.
(fix conflicts and run "git commit")
Unmerged paths:
(use "git add <file>..." to mark resolution)
both modified:

index.html

no changes added to commit (use "git add" and/or
"git commit -a")

Note que o arquivo index.html aparece como n√£o mesclado, como both
modified sob Unmerged paths (nomes n√£o muito intuitivos).
Agora teremos que realizar o merge manualmente. Nesse caso, a solu√ß√£o
√© f√°cil. Vamos editar o arquivo index.html da seguinte maneira:
148

Casa do C√≥digo

Cap√≠tulo 9. Lidando com conflitos

<!-- inicio do arquivo arquivo at√© h1 -->
<h2 id="mensagem" class="alert alert-info"></h2>
<p>Do lixo ao luxo, um resgate do descartado e uma transforma√ß√£o
em algo funcional. Reaproveitar √© aproveitar. Coisas descartadas
s√£o nossa carta na manga. Erodido, mas √∫nico.</p>
<!-- ul e restante do arquivo -->

Mesmo depois de editar o arquivo, removendo as marca√ß√µes de conflito
e mesclando manualmente as altera√ß√µes, ainda teremos a mesma resposta de
antes ao executarmos git status.
Para informarmos para o Git que resolvemos o conflito no arquivo, temos
que adicion√°-lo √† √°rea de stage executando git add index.html.
Agora, ao executarmos git status, teremos:
On branch master
Your branch is ahead of ‚Äôorigin/master‚Äô by 5 commits.
(use "git push" to publish your local commits)
All conflicts fixed but you are still merging.
(use "git commit" to conclude merge)
Changes to be committed:
modified:

index.html

Repare que o arquivo index.html aparece como modificado e est√°
pronto para ser comitado.
Depois disso, falta comitarmos as mudan√ßas com o comando git
commit -am "Resolvendo conflitos ap√≥s merge de design".
Como resposta, veremos:
[master 4444344] Resolvendo conflitos ap√≥s merge de design

Pronto! Conflito resolvido. Finalmente o merge foi finalizado.
Nossa p√°gina ficou com um visual bem razo√°vel:

149

9.3. Resolvendo conflitos ap√≥s um rebase

Casa do C√≥digo

Figura 9.1: P√°gina embelezada

9.3

Resolvendo conflitos ap√≥s um rebase

E se tiv√©ssemos utilizado um rebase para mesclar as √∫ltimas mudan√ßas da
branch design na master?
Devemos unir o commit 5555222 (Melhorando design do banner) da
branch design com o commit 9333339 (Adicionando texto criativo) da
branch master. Mas ambos alteram o topo do arquivo index.html, o que
gera um conflito.
Considerando que estamos na branch master, ap√≥s executar o comando
git rebase design, ver√≠amos:
First, rewinding head to replay your work on top of it...
Applying: Alterando textos do banner
Applying: Adicionando p√°gina sobre m√≥veis PET
Applying: Corrigindo t√≠tulo da p√°gina
Applying: Adicionando texto criativo
Using index info to reconstruct a base tree...
M
index.html
Falling back to patching base and 3-way merge...

150

Casa do C√≥digo

Cap√≠tulo 9. Lidando com conflitos

Auto-merging index.html
CONFLICT (content): Merge conflict in index.html
Failed to merge in the changes.
Patch failed at 0004 Adicionando texto criativo
The copy of the patch that failed is found in:
/home/fulanodasilva/moveis/.git/rebase-apply/patch
When you have resolved this problem, run "git rebase
--continue".
If you prefer to skip this patch, run "git rebase --skip"
instead.
To check out the original branch and stop rebasing, run
"git rebase --abort".

Observe que que aparece um conflito no arquivo index.html.
Ao executarmos o comando git status, ter√≠amos:
rebase in progress; onto 5555222
You are currently rebasing branch ‚Äômaster‚Äô on ‚Äô5555222‚Äô.
(fix conflicts and then run "git rebase --continue")
(use "git rebase --skip" to skip this patch)
(use "git rebase --abort" to check out the original branch)
Unmerged paths:
(use "git reset HEAD <file>..." to unstage)
(use "git add <file>..." to mark resolution)
both modified:

index.html

no changes added to commit (use "git add" and/or "git commit -a")

De maneira semelhante ao que aconteceu ap√≥s o conflito no merge, o arquivo index.html aparece em Unmerged paths como both modified. Apesar
da descri√ß√£o pouco intuitiva, isso indica que h√° um conflito nesse arquivo.
Ao abrirmos o arquivo index.html veremos as mesmas marca√ß√µes de
conflito com os textos <<<<<<< HEAD, ======= e >>>>>>> design.
Devemos mesclar o arquivo index.html manualmente, removendo as
marca√ß√µes de conflito, conforme fizemos anteriormente.
151

9.4. Usando uma ferramenta para resolver conflitos

Casa do C√≥digo

Para marcar a resolu√ß√£o do conflito, devemos executar
index.html.
Depois disso, ao executar git status, ter√≠amos:

git add

rebase in progress; onto 5555222
You are currently rebasing branch ‚Äômaster‚Äô on ‚Äô5555222‚Äô.
(all conflicts fixed: run "git rebase --continue")
Changes to be committed:
(use "git reset HEAD <file>..." to unstage)
modified:

index.html

Para finalizar o rebase, ter√≠amos que executar ainda:
$ git rebase --continue

Pronto! Finalmente finalizamos nosso rebase conflitante! Ufa!
Se quis√©ssemos abortar o rebase, voltando √† situa√ß√£o antes da tentativa de mesclagem, poder√≠amos executar git rebase --abort.
Tamb√©m poder√≠amos simplesmente ignorar o commit que gerou o
conflito, pulando-o, executando git rebase --skip. Essa op√ß√£o
tem que ser usada com cuidado. S√≥ faz sentido quando exatamente a
mesma altera√ß√£o foi feita na branch sendo mesclada.

9.4 Usando uma ferramenta para resolver conflitos
O conflito que acabamos de resolver foi bem f√°cil. Visualizar o arquivo para
decidir como mesclar as diferentes vers√µes n√£o demandou grande esfor√ßo.
Por√©m, algumas vezes temos conflitos bem desafiadores, em que √© dif√≠cil
visualizar cada trecho conflitante do arquivo.
Al√©m disso, podemos ter v√°rios arquivos com conflito para serem solucionados.
152

Casa do C√≥digo

Cap√≠tulo 9. Lidando com conflitos

Experi√™ncia no c√≥digo que est√° sendo desenvolvido e calma s√£o fundamentais para n√£o inserirmos erros ao resolver conflitos.
Mas utilizar uma ferramenta apropriada pode auxiliar na rapidez de resolu√ß√£o de conflitos.
Com Git, podemos invocar uma ferramenta de resolu√ß√£o de conflitos com
o comando:
$ git mergetool

Seriam exibidas mensagens parecidas com:
This message is displayed because ‚Äômerge.tool‚Äô is not
configured.
See ‚Äôgit mergetool --tool-help‚Äô or ‚Äôgit help config‚Äô for more
details. ‚Äôgit mergetool‚Äô will now attempt to use one of the
following tools: meld opendiff kdiff3 tkdiff xxdiff
tortoisemerge gvimdiff diffuse diffmerge ecmerge p4merge araxis
bc3 codecompare emerge vimdiff
Merging:
index.html
Normal merge conflict for ‚Äôindex.html‚Äô:
{local}: modified file
{remote}: modified file
Hit return to start merge resolution tool (meld):

Leia com aten√ß√£o a mensagem anterior. Repare que o Git listou algumas
ferramentas para resolu√ß√£o de conflitos como Meld (http://meldmerge.org) ,
bem simples e efetiva que funciona em Windows, Mac OS e Linux, TortoiseMerge (http://tortoisesvn.net/TortoiseMerge.html) , bastante utilizada mas
s√≥ para Windows, entre outras.
Alguma das ferramentas listadas anteriormente ser√° procurada e invocada.
Na mensagem anterior, foi indicada a ferramenta Meld. Pressionando a
tecla Enter, a ferramenta √© aberta:

153

9.4. Usando uma ferramenta para resolver conflitos

Casa do C√≥digo

Figura 9.2: Meld, ferramenta de resolu√ß√£o de conflitos

Para definir uma ferramenta padr√£o para resolu√ß√£o de conflitos podemos utilizar a configura√ß√£o merge.tool.
Por exemplo, para sempre utilizar o Meld, poder√≠amos executar git
config --global merge.tool meld. O comando meld deve estar no PATH do sistema operacional.
No Meld, o arquivo index.html foi aberto √† esquerda com o conte√∫do
da master, √† direita com o conte√∫do da branch design e no centro com
o conte√∫do anterior √†s duas modifica√ß√µes conflitantes. Devemos editar o arquivo do centro
Depois de resolvido o conflito usando o Meld e salvar o arquivo, se executarmos git status, teremos:
On branch master
Your branch is ahead of ‚Äôorigin/master‚Äô by 5 commits.
(use "git push" to publish your local commits)
All conflicts fixed but you are still merging.

154

Casa do C√≥digo

Cap√≠tulo 9. Lidando com conflitos

(use "git commit" to conclude merge)
Changes to be committed:
modified:

index.html

Untracked files:
(use "git add <file>..." to include in what will be committed)
index.html.orig

Note que o arquivo index.html est√° entre as mudan√ßas prontas
para serem comitadas. Al√©m disso, foi criado um novo arquivo chamado
index.html.orig com o conte√∫do original, antes do conflito ser resolvido.
O arquivo index.html.orig pode ser apagado.
Podemos, ent√£o, comitar o arquivo index.html agora sem conflitos, executando git commit -am "Resolvendo conflitos ap√≥s
merge de design". Na sa√≠da, teremos:
[master 1111114] Resolvendo conflitos ap√≥s merge de design

155

Cap√≠tulo 10

Maneiras de trabalhar com Git
No cap√≠tulo 3, vimos como trabalhar com um reposit√≥rio local do Git, criando
uma ‚Äúm√°quina do tempo‚Äù para o nosso c√≥digo.
J√° no cap√≠tulo 4, vimos como utilizar reposit√≥rios remotos para compartilhar nosso c√≥digo com os outros membros da nossa equipe, al√©m de manter
um backup do reposit√≥rio.
E no cap√≠tulo 5, utilizamos o Github para tornar nosso reposit√≥rio remoto
acess√≠vel de qualquer lugar que tenha acesso √† internet.
Depois, nos cap√≠tulos 6 e 7, utilizamos branches locais e remotas para
trabalhar em paralelo em diferentes funcionalidades de maneira organizada.
Estudamos tamb√©m, no cap√≠tulo 8, como marcar as vers√µes de nossas entregas atrav√©s de tags.
No cap√≠tulo 9 aprendemos como lidar com conflitos que acontecem ao
mesclar branches.

Casa do C√≥digo

Mas como usar tudo isso que aprendemos no seu projeto? Qual a melhor
maneira trabalhar com o Git no seu caso?

Modelos de distribui√ß√£o de reposit√≥rios e de branches
O Git √© um sistema de controle de vers√£o distribu√≠do. Temos localmente
uma c√≥pia completa do reposit√≥rio, que podemos compartilhar remotamente.
Al√©m disso, podemos apontar para mais de um reposit√≥rio remoto.
Por isso, uma das decis√µes que precisamos fazer √© o modelo de distribui√ß√£o de reposit√≥rios a ser adotado, definindo como organizar os reposit√≥rios
remotos. Os modelos mais utilizados s√£o:
‚Ä¢ Apenas um reposit√≥rio remoto, central, para onde os reposit√≥rios locais
apontam;
‚Ä¢ Cada desenvolvedor tem seu fork, um reposit√≥rio remoto que √© uma
c√≥pia do projeto, utilizando um reposit√≥rio central para integra√ß√£o;
‚Ä¢ Uma hierarquia de reposit√≥rios para integra√ß√£o.
Ao contr√°rio de outros sistemas de controle de vers√£o, criar branches no
Git √© algo muito leve e r√°pido. Al√©m disso, o Git √© muito bom em fazer mesclagens autom√°ticas, o que encoraja o uso de branches.
Portanto, outra coisa que precisamos decidir √© o modelo de branches a
ser utilizado no nosso projeto. Alguns dos modelos mais comuns s√£o:
‚Ä¢ Utilizar apenas a branch master;
‚Ä¢ Ter uma branch para cada nova funcionalidade, deixando a master
para c√≥digo pronto para ser entregue;
‚Ä¢ Ter algumas branches por etapa de desenvolvimento, como uma branch
de longo prazo para c√≥digo ainda em constru√ß√£o e uma de curto prazo
para corre√ß√µes de bugs urgentes.
Existem v√°rios fluxos de trabalho poss√≠veis ao se trabalhar com Git. Vamos estudar os mais comuns.
158

Casa do C√≥digo

10.1

Cap√≠tulo 10. Maneiras de trabalhar com Git

Utilizando s√≥ a branch master com um reposit√≥rio central

Um dos fluxos de trabalho mais simples √© utilizar apenas um reposit√≥rio central hospedado, por exemplo, no Github, comitando tudo diretamente na
branch local master.
Para enviar os commits locais, cada desenvolvedor faz um push para o reposit√≥rio central. Por isso, todos os membros da equipe devem ter permiss√µes
de push.

Figura 10.1: Reposit√≥rio central s√≥ com master

Considerando que temos um reposit√≥rio para o nosso projeto configurado no Github, a primeira coisa seria fazer:
$ git clone https://github.com/empresa/projeto.git

Ap√≥s o clone, temos uma c√≥pia local completa do reposit√≥rio.
Podemos, ent√£o, criar novos arquivos ou editar arquivos existentes.
Quando estivermos satisfeitos com o c√≥digo, podemos adicionar as altera√ß√µes √† √°rea de stage e depois comit√°-las na master, utilizando comandos
como:
$ git add .
$ git commit -m "Otimizando consulta a clientes"

159

10.1. Utilizando s√≥ a branch master com um reposit√≥rio central

Casa do C√≥digo

Depois de alguns commits, podemos compartilhar nosso trabalho com a
equipe:
$ git push origin master

Depois de termos publicado os novos commits, os outros desenvolvedores podem obt√™-los executando:
$ git pull --rebase origin master

Encorajamos o uso de um git pull --rebase ao obter mudan√ßas
remotas porque simplifica o hist√≥rico do reposit√≥rio, evitando commits
de merge.
Se ocorrer algum conflito no momento em que obtemos os novos commits, devemos resolver os problemas editando os arquivos apropriados para
ent√£o executar:
$ git add .
$ git rebase --continue

Quando estivermos prontos para fazer uma entrega, podemos marc√°-la
criando uma tag e, depois, enviando essa tag para o reposit√≥rio central:
$ git tag v1.0
$ git push origin --tags

Quando utilizar?
Para equipes pequenas ou na ado√ß√£o do Git.
Quando trabalhamos em equipes pequenas, com at√© 5 desenvolvedores,
quanto mais simples o fluxo de trabalho, melhor. Como a equipe √© pequena,
muito provavelmente o projeto ser√° pequeno e teremos controle no ritmo das
entregas, n√£o precisando de um fluxo mais poderoso (e complexo).
Esse fluxo √© parecido com a maneira como s√£o comumente utilizados sistemas de controle de vers√£o centralizados, como o Subversion. Por isso, para
160

Casa do C√≥digo

Cap√≠tulo 10. Maneiras de trabalhar com Git

equipes que est√£o iniciando com o Git, √© o fluxo de mais f√°cil ado√ß√£o. A equipe
pode focar em aprender os comandos b√°sicos do Git, utilizados para lidar com
um reposit√≥rio local, para depois partir para fluxos mais avan√ßados.

Vantagens
‚Ä¢ A simplicidade desse fluxo permite uma ado√ß√£o mais tranquila para
quem est√° come√ßando a utilizar o fluxo. Tamb√©m h√° menos complica√ß√£o para equipes reduzidas.
‚Ä¢ √â mais f√°cil de adotar integra√ß√£o cont√≠nua, uma pr√°tica bastante comum em projetos que usam metodologias √°geis. Nessa pr√°tica, o c√≥digo deve ser integrado frequentemente, disparando builds e testes automatizados e detectando erros de integra√ß√£o o mais r√°pido poss√≠vel.
Nesse fluxo, como toda altera√ß√£o √© comitada na branch master, todo
c√≥digo compartilhado depois de um push ser√° integrado na master
do reposit√≥rio central. A cada novo push, o build e os testes automatizados podem ser disparados utilizando esse c√≥digo integrado. Al√©m
disso, poss√≠veis conflitos s√£o detectados a cada pull.

Desvantagens
‚Ä¢ Ao corrigir defeitos urgentes, pode ser que o c√≥digo de novas funcionalidades ainda em desenvolvimento j√° tenha sido compartilhado na
branch master do reposit√≥rio central. Com esse fluxo, fica dif√≠cil separar o c√≥digo da corre√ß√£o do defeito do c√≥digo das novas funcionalidades, o que pode gerar mais defeitos e insatisfa√ß√£o nos clientes.
‚Ä¢ Como tudo √© comitado na branch master, as entregas s√£o feitas com
todo o c√≥digo que est√° no reposit√≥rio no momento da entrega. N√£o √©
poss√≠vel entregar s√≥ parte das funcionalidades que foram compartilhadas com o reposit√≥rio central.
‚Ä¢ H√° a necessidade de permiss√£o de push para todos os membros da
equipe no reposit√≥rio central, j√° que h√° apenas um reposit√≥rio remoto.
161

10.2. Utilizando branches por funcionalidade com um reposit√≥rio central

Casa do C√≥digo

Para projetos open source, √© algo invi√°vel. Para projetos e equipes muito
grandes, pode tamb√©m ser um problema.

10.2 Utilizando branches por funcionalidade
com um reposit√≥rio central
Podemos utilizar branches para isolar o c√≥digo de novas funcionalidades ou
altera√ß√µes em funcionalidades existentes. A branch master passa a ser tratada de maneira especial, ficando est√°vel durante todo o desenvolvimento
do projeto. S√≥ quando a funcionalidade estiver pronta, √© feito um merge da
branch da funcionalidade na master.
Se for preciso realizar uma corre√ß√£o urgente, pode ser utilizada a branch
master diretamente. Para corre√ß√µes ou altera√ß√µes mais demoradas, podem
ser criadas branches para segregar os commits da corre√ß√£o.
Essa maneira de trabalhar tamb√©m √© chamada de feature branching
ou topic branching.

Figura 10.2: Reposit√≥rio central com branches por funcionalidade

Vamos dizer que temos um reposit√≥rio local clonado a partir de um reposit√≥rio do Github, como fizemos anteriormente, com o comando git clone
https://github.com/empresa/projeto.git .
A funcionalidade a ser desenvolvida √© a cria√ß√£o de pedidos de nossa loja
162

Casa do C√≥digo

Cap√≠tulo 10. Maneiras de trabalhar com Git

online. Antes de come√ßar, vamos criar a partir da master uma branch chamada pedidos, j√° mudando pra essa nova branch:
$ git checkout -b pedidos

J√° na branch pedidos, podemos come√ßar a trabalhar na funcionalidade,
criando novos arquivos e alterando arquivos existentes. Em seguida, podemos efetuar commits com os comandos que j√° conhecemos:
$ git add .
$ git commit -m "Tela inicial de pedidos"

Depois de alguns commits, mesmo sem termos terminado a funcionalidade de pedidos, podemos compartilhar o c√≥digo que fizemos enviando-o
para o reposit√≥rio central. Basta executar:
$ git push origin pedidos

Com o c√≥digo no reposit√≥rio central, temos um backup do c√≥digo e outros membros da nossa equipe podem obt√™-lo para colaborar no desenvolvimento da funcionalidade. Tudo isso sem afetar a estabilidade da branch
master.
O restante da nossa equipe, para poder trabalhar na funcionalidade, precisa obter as √∫ltimas altera√ß√µes do reposit√≥rio central e, em seguida, criar uma
c√≥pia local da branch pedidos. Para isso, deve-se executar:
$ git fetch origin
$ git checkout -t origin/pedidos

N√≥s e outros membros da equipe podemos fazer commits e, quando apropriado, compartilhar o c√≥digo por meio do reposit√≥rio central atrav√©s do comando:
$ git push origin pedidos

Para obtermos o novo c√≥digo da funcionalidade, ainda na branch
pedidos, devemos fazer:
$ git pull --rebase origin pedidos

163

10.2. Utilizando branches por funcionalidade com um reposit√≥rio central

Casa do C√≥digo

No caso de conflitos ap√≥s o pull com rebase, devemos mesclar os arquivos
manualmente e executar:
$ git add .
$ git rebase --continue

A branch pedidos do reposit√≥rio central ter√° o c√≥digo que integra as
mudan√ßas de todos os membros da equipe. Testadores e outros interessados
podem utilizar o c√≥digo da branch pedidos para verificar o andamento das
atividades e detectar problemas. Revisar a qualidade do c√≥digo, por exemplo, fica mais f√°cil porque as mudan√ßas relacionadas √† funcionalidade ficam
isoladas.
Caso haja alguma altera√ß√£o feita diretamente na master, como uma corre√ß√£o de um defeito urgente, √© importante obt√™-la no reposit√≥rio local. Para
isso, continuando na branch pedidos, devemos executar:
$ git pull --rebase origin master

O comando anterior obt√©m as mudan√ßas da branch remota
origin/master e j√° faz o rebase na branch atual, que √© a pedidos.
Seria equivalente √† sequ√™ncia de comandos:
$
$
$
$

git
git
git
git

checkout master
pull origin master
checkout pedidos
rebase master

A diferen√ßa √© que, nessa √∫ltima sequ√™ncia, a branch local master
ficaria atualizada com as √∫ltimas mudan√ßas da origin/master.
Quando a equipe estiver satisfeita com a funcionalidade e com o c√≥digo,
algum dos desenvolvedores pode fazer o merge na branch master.
Antes, √© importante nos certificarmos de que a branch master cont√©m
as √∫ltimas modifica√ß√µes do reposit√≥rio central. Podemos utilizar um pull sem
rebase, para deixarmos a master intacta. √â tranquilo fazer o pull sem rebase

164

Casa do C√≥digo

Cap√≠tulo 10. Maneiras de trabalhar com Git

nesse caso porque, muito provavelmente, ser√° feito um merge do estilo fastforward, j√° que n√£o √© comum fazermos commits diretamente na master.
Na branch pedidos, devemos executar os comandos:
$ git checkout master
$ git pull origin master
$ git merge pedidos

H√° casos em que a equipe tem muitos membros e/ou tem problemas
na comunica√ß√£o. Em vez do merge, talvez seja melhor fazer um git
pull origin pedidos (ainda na branch master). Tamb√©m seria
realizado um merge, mas com poss√≠veis altera√ß√µes de √∫ltima hora.
No caso de conflitos no merge da branch da funcionalidade, devemos resolver os conflitos manualmente para depois executar:
$ git add .
$ git commit -m "Resolvendo conflitos no merge de pedidos"

Depois de realizado o merge da branch pedidos com a branch local
master, podemos compartilhar o c√≥digo executando:
$ git push origin master

No momento adequado, podemos liberar uma nova vers√£o do sistema,
marcando a entrega com uma tag atrav√©s do comando git tag v1.0
e compartilhando a tag criada com o comando $ git push origin
--tags.
Se n√£o quisermos entregar alguma funcionalidade na nova vers√£o do sistema, basta n√£o fazermos o merge da branch da funcionalidade na branch
master.

165

10.2. Utilizando branches por funcionalidade com um reposit√≥rio central

Casa do C√≥digo

Quando utilizar?
Em projetos um pouco maiores, principalmente se j√° tiverem algumas
entregas feitas. √â importante que a equipe tenha familiaridade no uso do Git.
Para projetos que j√° est√£o a todo vapor, com melhorias e corre√ß√µes que
precisam ser feitas de imediato, isolar c√≥digo que ainda est√° sendo desenvolvimento √© algo importante. Com o uso de uma branch para cada funcionalidade, podemos organizar o desenvolvimento das novas funcionalidades de
maneira a n√£o afetar demandas urgentes.
Para que essa fluxo seja usado com flu√™ncia, √© preciso que os desenvolvedores j√° estejam confort√°veis com o uso b√°sico do Git.

Vantagens
‚Ä¢ Podemos isolar c√≥digo mais est√°vel na branch master, facilitando a
realiza√ß√£o de melhorias e corre√ß√µes imediatas.
‚Ä¢ Revis√µes da qualidade do novo c√≥digo que implementa uma funcionalidade podem ser feitas analisando os commits da branch da funcionalidade.
‚Ä¢ Pode ser entregue apenas parte das funcionalidades que est√£o sendo
desenvolvidas, possibilitando mudan√ßas mais tranquilas na estrat√©gia
de neg√≥cio do nosso cliente.

Desvantagens
‚Ä¢ Como a equipe precisa dominar o Git razoavelmente bem, o uso desse
fluxo no in√≠cio da ado√ß√£o do Git fica dificultado.
‚Ä¢ Como trabalhamos com um reposit√≥rio central, ainda h√° a necessidade
de permiss√£o de push para todos os membros da equipe. Por isso, esse
fluxo pode ser problem√°tico para grandes equipes e torna-se invi√°vel
para projetos open source.
‚Ä¢ O c√≥digo de uma funcionalidade s√≥ √© efetivamente integrado com outras mudan√ßas no momento do merge final com a branch master.
166

Casa do C√≥digo

Cap√≠tulo 10. Maneiras de trabalhar com Git

Com outras funcionalidades em desenvolvimento, poss√≠veis conflitos
entre o c√≥digo das funcionalidades s√≥ ser√£o descobertos tardiamente,
ao mesclarmos todas as branches.
‚Ä¢ Realizar integra√ß√£o cont√≠nua, descobrindo problemas no c√≥digo e nas
funcionalidades rapidamente, fica mais dif√≠cil. A grande vantagem
desse fluxo, que √© a de isolar c√≥digo das funcionalidades, torna-se a pior
desvantagem sob a √≥tica de integra√ß√£o cont√≠nua. Por isso, especialistas
em integra√ß√£o cont√≠nua n√£o recomendam o uso de branches por funcionalidade, favorecendo o isolamento das funcionalidades com uma
arquitetura mais modular, utilizando abstra√ß√µes para grandes altera√ß√µes no c√≥digo (branch by abstraction) e configura√ß√µes para desabilitar
funcionalidades novas (feature toggles).

10.3

Utilizando branches por etapa de desenvolvimento com um reposit√≥rio central

Ao comitarmos um novo c√≥digo em uma branch separada para uma funcionalidade espec√≠fica, mantemos a branch local master est√°vel, mas corremos
o risco de adiar demais a integra√ß√£o entre os c√≥digos das novas funcionalidades. Essa demora pode levar a defeitos que deixariam nossos clientes insatisfeitos.
Para evitar a integra√ß√£o tardia das funcionalidades, poder√≠amos ter uma
branch para c√≥digo ainda em desenvolvimento, chamada desenv. Seria uma
branch de longo prazo, que existiria enquanto o projeto estiver sendo desenvolvido. A branch master teria c√≥digo j√° pronto pra ser entregue. J√° a branch
desenv teria c√≥digo para a pr√≥xima entrega. Quando tivermos um ponto est√°vel no novo c√≥digo, far√≠amos um merge da desenv na master.
Podemos continuar utilizando branches por funcionalidade mas, agora,
criando-as a partir da branch desenv. Periodicamente, poder√≠amos efetuar um merge precoce das branches das funcionalidades, mesmo antes de
o c√≥digo estar totalmente finalizado. Assim, evitar√≠amos a integra√ß√£o tardia e
deixar√≠amos de afetar a branch master.
Seria interessante termos branches de release, para comitarmos c√≥digo referente a uma determinada entrega, como corre√ß√µes de √∫ltima hora de pe167

10.3. Utilizando branches por etapa de desenvolvimento com um reposit√≥rio central Casa do C√≥digo

quenos bugs descobertos logo antes de liberar uma vers√£o. Teriam nomes
como release1.1 ou release2.0 e seriam criadas a partir da desenv.
Tamb√©m poderiam ser comitados nessas branches de release c√≥digos necess√°rios para preparar uma entrega, como arquivos de vers√£o e release notes.
Seriam branches de curto prazo, que poderiam ser deletadas quando n√£o fizerem mais sentido. Os commits das corre√ß√µes feitas nessas branches de release
precisariam ser aplicados na master e na desenv, atrav√©s de um merge.
Para bugs urgentes, que afetam vers√µes em produ√ß√£o, poder√≠amos criar
uma branch de hotfix. Se estivermos com a vers√£o 1.0 em produ√ß√£o e acontecer um defeito que pode ser corrigido de maneira imediata, poder√≠amos criar
a branch hotfix-1.0.1 a partir da master. A corre√ß√£o seria feita nessa
nova branch e, quando finalizada, far√≠amos um merge na branch master.
Tamb√©m √© importante efetuarmos um merge na branch desenv, para obtermos a corre√ß√£o do defeito. Uma branch de hotfix √© de curto prazo e, depois
de feito o merge, podemos apag√°-la.

Figura 10.3: Reposit√≥rio central com branches por etapa de desenvolvimento

Como nos fluxos de trabalho anteriores, cada desenvolvedor deve fazer
o clone do reposit√≥rio central executando, por exemplo, git clone https:
168

Casa do C√≥digo

Cap√≠tulo 10. Maneiras de trabalhar com Git

//github.com/empresa/projeto.git .

Logo no in√≠cio do projeto, ou em algum outro momento apropriado, podemos criar uma branch local chamada desenv, a partir da master, para
comitarmos c√≥digo ainda em desenvolvimento. Tamb√©m √© importante que
essa branch exista no reposit√≥rio central. Para isso, um dos desenvolvedores
deve executar:
$ git branch desenv
$ git push origin desenv

Para come√ßarem a trabalhar na branch desenv, os desenvolvedores precisam criar uma branch local que aponta para a branch remota
origin/desenv do reposit√≥rio central. Para isso, devem executar:
$ git fetch origin
$ git checkout -t origin/desenv

Para trabalharmos em uma nova funcionalidade, por exemplo de estoque, podemos criar uma branch para essa funcionalidade a partir da branch
desenv, executando:
$ git checkout -b estoque desenv

Podemos efetuar alguns commits e, depois, compartilhar a branch com a
nossa equipe, atrav√©s do comando git push origin estoque.
No momento adequado, devemos fazer o merge da funcionalidade
estoque na branch desenv, integrando-a com as outras funcionalidades
que j√° foram mescladas com desenv. Por√©m, antes do merge, √© importante obtermos as √∫ltimas mudan√ßas em desenv feitas pelos outros membros da nossa equipe atrav√©s de um pull de origin/desenv. Depois do
merge, podemos compartilhar a branch desenv que j√° ter√° os √∫ltimos commits da estoque. Para fazer isso tudo, considerando que estamos na branch
estoque, devemos executar:
$
$
$
$

git
git
git
git

pull origin desenv
checkout desenv
merge estoque
push origin desenv

169

10.3. Utilizando branches por etapa de desenvolvimento com um reposit√≥rio central Casa do C√≥digo

Podemos repetir os comandos anteriores sempre que quisermos integrar
a branch da funcionalidade estoque com a branch desenv. Ao terminarmos a funcionalidade, devemos fazer um √∫ltimo merge em desenv. Se
quisermos, podemos deletar nossa branch local estoque com o comando
git branch -d estoque.
Quando estivermos satisfeitos com as funcionalidades que foram mescladas na branch desenv, podemos criar uma branch para a pr√≥xima release
com um nome como release-1.0 a partir da desenv. Para isso, devemos
executar:
$ git checkout -b release-1.0 desenv

Na branch release-1.0 podemos comitar, por exemplo, um arquivo
listando as novas funcionalidades (o release notes), modificar arquivos para
preparar a entrega. Al√©m disso, podemos comitar corre√ß√µes de pequenos bugs
que descobrirmos antes de liberar a nova vers√£o. Enquanto isso, outros desenvolvedores podem come√ßar a trabalhar nas funcionalidades da pr√≥xima
entrega, comitando na branch desenv.
Para fecharmos a nova vers√£o, devemos fazer o merge da nossa branch
release-1.0 na branch master. Para isso, devemos executar os comandos:
$ git checkout master
$ git merge release-1.0
$ git push origin master

Tamb√©m √© importante, ainda na branch master, marcamos a nova vers√£o com uma tag:
$ git tag v1.0
$ git push origin --tags

Se tivermos comitado corre√ß√µes de bugs na branch release-1.0, √© importante aplicarmos o c√≥digo corrigido na branch desenv, atrav√©s de um
merge. Para isso, devemos executar:
$ git checkout desenv
$ git merge release-1.0
$ git push origin desenv

170

Casa do C√≥digo

Cap√≠tulo 10. Maneiras de trabalhar com Git

Se quisermos, podemos deletar a branch local release-1.0 atrav√©s do
comando git branch -d release-1.0.
Caso aconte√ßa um bug em produ√ß√£o que deve ser corrigido imediatamente, podemos criar uma branch para trabalharmos na corre√ß√£o. Se a vers√£o
atual for a 1.0, poder√≠amos cham√°-la de hotfix-1.0.1. J√° que a branch
master cont√©m o c√≥digo da √∫ltima vers√£o liberada para produ√ß√£o, devemos
criar a nova branch de corre√ß√£o a partir da master. Para cri√°-la, devemos executar:
$ git checkout -b hotfix-1.0.1 master

Depois de descobrimos a causa do defeito e termos comitado o c√≥digo
com a corre√ß√£o, podemos fazer o merge da branch hotfix-1.0.1 na
branch master. Ent√£o, devemos executar:
$ git checkout master
$ git merge hotfix-1.0.1
$ git tag 1.0.1

N√£o podemos esquecer de aplicar a corre√ß√£o do defeito na branch
desenv, que cont√©m o c√≥digo que est√° sendo desenvolvido. Podemos fazer
isso executando:
$ git checkout desenv
$ git merge hotfix-1.0.1

Feitos os merges da branch hotfix-1.0.1 nas branches master
e desenv podemos apag√°-la com o comando git branch -d
hotfix-1.0.1.

Quando utilizar?
Em projetos complexos, que j√° t√™m v√°rias entregas e com diversas novas
funcionalidades em desenvolvimento. A equipe j√° deve ter um bom dom√≠nio
do Git.
Esse fluxo que usa branches por etapa de desenvolvimento deixa o trabalho bastante organizado. A branch de desenvolvimento serve como uma
branch de integra√ß√£o para as diferentes branches de funcionalidade. J√° a
171

10.3. Utilizando branches por etapa de desenvolvimento com um reposit√≥rio central Casa do C√≥digo

branch master n√£o √© afetada pelo dia a dia, ficando bastante est√°vel porque
s√≥ tem novo c√≥digo nos momentos de entrega e corre√ß√µes urgentes. Ajustes
finos e c√≥digo para preparar a entrega tem seu lugar, nas branches de release.
Bugs urgentes podem ser corrigidos nas branches de hotfix.
Devido √† complexidade no uso das variadas branches, para trabalhar
dessa maneira, o dom√≠nio dos conceitos do Git pelos membros da equipe √©
bastante importante.
Um fluxo parecido com esse √© chamado por alguns de Gitflow, mas n√£o
√© um fluxo ‚Äúoficial‚Äù, apesar do apelido. Foi descrito por Vincent Driessen em
2010, em seu blog: http://nvie.com/posts/a-successful-git-branching-model/

Vantagens
‚Ä¢ A branch master fica bem est√°vel, podendo ser utilizada at√© para disparar implanta√ß√µes autom√°ticas do software.
‚Ä¢ Conseguimos descobrir conflitos ou erros entre c√≥digos das novas funcionalidades mais cedo se mesclarmos as branches das funcionalidades
na branch desenv periodicamente.
‚Ä¢ Como utilizamos branches por funcionalidade, revis√µes do c√≥digo das
funcionalidade s√£o f√°ceis de fazer.
‚Ä¢ Podemos entregar apenas parte das funcionalidades, bastando deixar
o c√≥digo isolado na branch da funcionalidade que n√£o entrar√° na nova
vers√£o. Por√©m, se fizermos integra√ß√µes peri√≥dicas em desenv, isso
pode ser um desafio.
‚Ä¢ Corre√ß√µes urgentes t√™m um lugar definido nesse fluxo: as branches de
hotfix.
‚Ä¢ Trabalho relacionado com a prepara√ß√£o de uma nova vers√£o e ajustes
finos antes da libera√ß√£o podem ser feitos em uma branch de release.

172

Casa do C√≥digo

Cap√≠tulo 10. Maneiras de trabalhar com Git

Desvantagens
‚Ä¢ A equipe precisa de um bom dom√≠nio do Git.
‚Ä¢ √â um fluxo complexo. Por isso, √© melhor utilizar esse fluxo em projetos
grandes e/ou quando o projeto est√° a todo vapor. A√≠, a organiza√ß√£o do
trabalho compensa a complexidade.
‚Ä¢ Todos os membros da nossa equipe precisam de permiss√£o de push no
reposit√≥rio central, inviabilizando o uso em projetos open source e em
equipes grandes.
‚Ä¢ Mesmo com a branch desenv, que serve como uma branch de integra√ß√£o, s√≥ integraremos efetivamente o c√≥digo nos momentos em que
fizermos o merge das branches das funcionalidades na desenv. Por
isso, especialistas em integra√ß√£o cont√≠nua ainda criticam o uso desse
fluxo, argumentando que essa integra√ß√£o ainda √© feita tarde demais. Se
esse fluxo for utilizado sem branches por funcionalidade, a situa√ß√£o √©
melhorada, mas perder√≠amos as vantagens de isolarmos o c√≥digo das
funcionalidades em desenvolvimento.

10.4

Colaborando com projetos open source
com Fork e Pull Request

Utilizar um reposit√≥rio central √© algo bastante comum para projetos internos
de empresas. J√° para projetos open source precisamos de uma maneira mais
flex√≠vel, que n√£o necessite de permiss√µes de push para as dezenas ou centenas
de colabores do nosso projeto.
Servi√ßos como o Github permitem que um colaborador fa√ßa forks de um
projeto, criando uma c√≥pia p√∫blica do reposit√≥rio. Essa c√≥pia fica publicada
na web, servindo como o reposit√≥rio remoto do colaborador. Assim, os colaboradores podem comitar mudan√ßas em suas c√≥pias do projeto, sem precisar
de permiss√µes de push para o projeto original.
O colaborador pode criar um reposit√≥rio local que aponta para o seu reposit√≥rio remoto. Depois de comitar algumas modifica√ß√µes, pode ser feito o
173

10.4. Colaborando com projetos open source com Fork e Pull Request

Casa do C√≥digo

push para sua c√≥pia do projeto. Se desejar, pode at√© liberar acesso de push ao
seu reposit√≥rio remoto para outras pessoas colaborarem na sua c√≥pia.
Quando o colaborador estiver satisfeito com seu c√≥digo, √© poss√≠vel enviar
um pull request para o projeto principal. O mantenedor do projeto, a pessoa
respons√°vel pelo reposit√≥rio original, pode revisar a c√≥pia p√∫blica do colaborador e sugerir melhorias no c√≥digo.
Quando o mantenedor estiver satisfeito, √© poss√≠vel aceitar o pull request,
aplicando as mudan√ßas no reposit√≥rio original.
√â interessante que o colaborador fa√ßa seus commits em uma branch de
funcionalidade, separada da master. Dessa maneira, na hora de aplicar o
pull request, o mantenedor do projeto original teria os commits do colaborador em uma branch separada, podendo comitar melhorias. Tamb√©m √© poss√≠vel utilizar branches por etapa de desenvolvimento para projetos open source
maiores.

Figura 10.4: Fork e Pull Request

Quando utilizar?
Em projetos open source de pequeno ou m√©dio porte.
Para projeto open source muito grandes, com milhares de colaboradores,
o n√∫mero de pull requests seria t√£o grande que tornaria invi√°vel o uso desse
fluxo.
174

Casa do C√≥digo

Cap√≠tulo 10. Maneiras de trabalhar com Git

Tamb√©m √© poss√≠vel utilizar esse modelo em projetos de empresas, no caso
de projetos que tenham colaboradores externos e/ou n√£o confi√°veis.

Vantagens
‚Ä¢ N√£o √© necess√°rio dar permiss√µes de push para todos os colaboradores
do projeto.
‚Ä¢ √â um bom modelo para projetos open source de pequeno ou m√©dio
porte.

Desvantagens
‚Ä¢ A integra√ß√£o das mudan√ßas dos forks √© feita de maneira bem tardia.
Poss√≠veis conflitos e/ou erros seriam descobertos apenas na hora de
aplicarmos o pull request.
‚Ä¢ Como s√≥ h√° um reposit√≥rio original com, provavelmente apenas um
mantenedor, o n√∫mero de pull requests poderia ir acumulando. Para
projetos open source muito grandes √© necess√°ria uma outra abordagem.

10.5 Organizando projetos open source gigantescos com Ditador e Tenentes
Para projetos open source como o kernel do Linux, que tem milh√µes de linhas
de c√≥digo e milhares de colaboradores, utilizar o fluxo de trabalho anterior
torna-se invi√°vel.
O n√∫mero de pull requests criados seria enorme. Com apenas um mantenedor, seria imposs√≠vel dar vaz√£o √†s colabora√ß√µes.
Para esse tipo de projeto, o mantenedor do projeto original pode ficar
como um ditador benevolente, que tem a √∫ltima palavra sobre o c√≥digo do
projeto mas que aceitas sugest√µes. No caso do Linux, o ditador √© Linus Torvalds.
O ditador elegeria colaboradores que se mostraram competentes no passado para manter reposit√≥rios p√∫blicos com c√≥pias do projeto. Essas c√≥pias,
175

10.5. Organizando projetos open source gigantescos com Ditador e Tenentes

Casa do C√≥digo

em geral, teriam um foco em algum m√≥dulo espec√≠fico do projeto. Os eleitos
pelo ditador serviriam como tenentes, recebendo pull requests dos milhares
de outros colaboradores e revisando o c√≥digo, filtrando apenas as colabora√ß√µes realmente boas.
Um novo colaborador teria de escolher um dos reposit√≥rios dos tenentes
para fazer seu fork do projeto, provavelmente considerando o m√≥dulo em que
quer colaborar. Depois de feitos seus commits, faria o push para seu reposit√≥rio. Ent√£o, poderia fazer um pull request para seu tenente, que faria uma
revis√£o e daria um feedback.
Quando apropriado, o tenente faria pull requests para o reposit√≥rio do
ditador, sinalizando um pacote interessante de mudan√ßas.

Na verdade, o kernel do Linux n√£o utiliza pull requests e nem o
Github. No Github, h√° uma c√≥pia s√≥ para leitura do reposit√≥rio original.
Os commits s√£o enviados dos colaboradores para os tenentes e dos
tenentes para o ditador Linus por e-mail.
√â usado o comando git format-patch para criar um arquivo
.patch com um conjunto de commits. Os patches s√£o enviados por
e-mail com o comando git send-mail. Ent√£o, deve ser utilizado o
comando git am para aplicar os commits recebidos por e-mail.
√â interessante utilizar branches por funcionalidade e por etapa de desenvolvimento ao utilizar esse fluxo de trabalho.

176

Casa do C√≥digo

Cap√≠tulo 10. Maneiras de trabalhar com Git

Figura 10.5: Ditador e Tenentes

Quando utilizar?
Para projetos open source grandes, com milhares de colaboradores.

Vantagens
‚Ä¢ Assim como no fluxo anterior, n√£o s√£o necess√°rias permiss√µes de push
para o reposit√≥rio original, do ditador, nem dos tenentes.
‚Ä¢ √â um fluxo que funciona bem em projetos open source de grande porte.

Desvantagens
‚Ä¢ √â um fluxo de trabalho extremamente complicado, que requer muita
familiaridade com o Git.
‚Ä¢ A integra√ß√£o √© feita de maneira tardia, s√≥ quando for aplicado o pull
request (ou os patches recebidos por e-mail).
177

Cap√≠tulo 11

Ap√™ndice GitHub no Windows
Conforme visto nos cap√≠tulos anteriores, neste livro utilizamos o Git via linha
de comando, pelo Terminal, no caso do Linux e Mac, ou pelo Git Bash, no
caso do Windows.
Embora seja poss√≠vel fazer tudo via linha de comando, muitos usu√°rios do
Git, principalmente os que utilizam o Windows e n√£o t√™m o h√°bito de acessar
o prompt de comandos, n√£o gostam dessa abordagem, preferindo utiliz√°-lo
com o aux√≠lio de alguma aplica√ß√£o visual.
Existem algumas aplica√ß√µes visuais para o Git no Windows, dentre elas o
GitHub for Windows, criada pelo pessoal do GitHub.
Neste cap√≠tulo veremos como instalar e utilizar o GitHub for Windows.

11.1. Instalando o GitHub for Windows

Casa do C√≥digo

11.1 Instalando o GitHub for Windows
Primeiramente devemos baixar a aplica√ß√£o, o que fazemos acessando o site
http://windows.github.com e clicando no bot√£o Download GitHub for Windows:

Figura 11.1: P√°gina do GitHub for Windows com o bot√£o para download

Vers√µes suportadas
O GitHub for Windows funciona apenas no Windows Vista, Windows 7 e Windows 8.
Ap√≥s o download do arquivo, devemos execut√°-lo dando um duplo
clique, e ser√° exibida a tela de instala√ß√£o:

180

Casa do C√≥digo

Cap√≠tulo 11. Ap√™ndice GitHub no Windows

Figura 11.2: Tela de instala√ß√£o

Ap√≥s a instala√ß√£o ser conclu√≠da veremos uma tela onde devemos informar
nosso usu√°rio e senha cadastrados no GitHub, e clicar no bot√£o Log in:

181

11.1. Instalando o GitHub for Windows

Casa do C√≥digo

Figura 11.3: Tela onde informamos os dados de login do GitHub

Na pr√≥xima tela devemos informar o Nome e o E-mail do nosso usu√°rio
Git e clicar no bot√£o continue. Esse passo √© equivalente a executar os comandos git config --global user.name e git config --global
user.email.

182

Casa do C√≥digo

Cap√≠tulo 11. Ap√™ndice GitHub no Windows

Figura 11.4: Tela de configura√ß√£o dos dados do usu√°rio Git

Por fim, veremos a tela onde ser√£o listados os reposit√≥rios Git encontrados em nosso computador, se houver, ou uma mensagem informando que n√£o
foram encontrados reposit√≥rios. No nosso caso clicaremos no bot√£o Skip,
pois vamos adicionar os reposit√≥rios posteriormente.

183

11.1. Instalando o GitHub for Windows

Casa do C√≥digo

Figura 11.5: Tela listando os reposit√≥rios Git

Ap√≥s clicar no bot√£o Skip, seremos direcionados para a tela principal da
aplica√ß√£o, conhecida como Dashboard:

184

Casa do C√≥digo

Cap√≠tulo 11. Ap√™ndice GitHub no Windows

Figura 11.6: Tela de dashboard

Neste ponto j√° temos a aplica√ß√£o instalada, e se verificarmos a √Årea de
Trabalho veremos que foram adicionados dois novos atalhos, sendo um
chamado GitHub, que serve para executar o GitHub for Windows, e outro
chamado Git Shell, para executar o Git via prompt de comando:

185

11.2. Criando um novo reposit√≥rio

Casa do C√≥digo

Figura 11.7: √Årea de trabalho com os novos atalhos

O GitHub for Windows tamb√©m criar√° um novo diret√≥rio chamado
GitHub, localizado na pasta Documentos do usu√°rio. Esse √© o diret√≥rio
padr√£o onde os novos reposit√≥rios ser√£o criados.

11.2

Criando um novo reposit√≥rio

Agora que j√° temos o GitHub for Windows instalado e configurado, podemos
criar um novo reposit√≥rio Git. Para isto, basta clicar no bot√£o + localizado na
tela principal da aplica√ß√£o:

186

Casa do C√≥digo

Cap√≠tulo 11. Ap√™ndice GitHub no Windows

Figura 11.8: Tela de cria√ß√£o de novo reposit√≥rio

Devemos preencher o nome do reposit√≥rio no campo Name, e no campo
Local path escolher o diret√≥rio onde o reposit√≥rio dever√° ser criado, ou
deixar preenchido com o diret√≥rio padr√£o.
Note que h√° tamb√©m um campo chamado Git ignore, onde podemos escolher a linguagem de programa√ß√£o utilizada no projeto, dentre as op√ß√µes
dispon√≠veis, e com isto o arquivo .gitignore ser√° criado automaticamente.
Ap√≥s preencher os campos, devemos clicar no bot√£o Create repository,
aguardar a cria√ß√£o do reposit√≥rio e ent√£o veremos a tela Dashboard listando
o novo reposit√≥rio:

187

11.3. Efetuando commits no reposit√≥rio

Casa do C√≥digo

Figura 11.9: Tela dashboard com o novo reposit√≥rio

Repare que a tela agora est√° dividida em tr√™s colunas, onde na primeira
s√£o listados os reposit√≥rios Git, na segunda os commits do reposit√≥rio juntamente com um formul√°rio para efetuar um novo commit, e na √∫ltima coluna
s√£o exibidos os arquivos do reposit√≥rio.

11.3

Efetuando commits no reposit√≥rio

Vamos agora criar um novo arquivo no reposit√≥rio e em seguida efetuar um
commit. Para isso, acesse o diret√≥rio do reposit√≥rio e crie um novo arquivo
chamado teste.html com o seguinte conte√∫do:
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<title>GitHub for Windows</title>
</head>
<body>
<h1>Bem vindo!</h1>
</body>

188

Casa do C√≥digo

Cap√≠tulo 11. Ap√™ndice GitHub no Windows

</html>

Agora ao voltar para o GitHub for Windows veremos o novo arquivo
sendo listado:

Figura 11.10: Tela dashboard listando o novo arquivo

Para efetuar o commit do arquivo, basta digitar a mensagem do commit
no campo Summary e, opcionalmente, preencher uma descri√ß√£o mais detalhada do commit no campo Description, e ent√£o efetuar o commit clicando
no bot√£o commit to master:

189

11.4. Detalhando os commits

Casa do C√≥digo

Figura 11.11: Efetuando o primeiro commit

Repare que na listagem dos arquivos √© poss√≠vel selecionar quais dos arquivos ser√£o comitados.

11.4

Detalhando os commits

Vamos efetuar um novo commit no reposit√≥rio. Para isso, altere o arquivo
teste.html adicionando o seguinte conte√∫do:
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<title>GitHub for Windows</title>
</head>
<body>
<h1>Bem vindo!</h1>
<p>Alteracao qualquer</p>
</body>
</html>

E ap√≥s isto registre a altera√ß√£o com um novo commit:
190

Casa do C√≥digo

Cap√≠tulo 11. Ap√™ndice GitHub no Windows

Figura 11.12: Registrando o novo commit

Ap√≥s efetuar o commit repare que o mesmo √© exibido na listagem de commits, onde √© exibida a mensagem, o autor e a data em que cada commit foi
realizado.
Ao clicar em algum dos commits veremos as altera√ß√µes realizadas naquele
commit em espec√≠fico:

Figura 11.13: Detalhamento das modifica√ß√µes realizadas no commit

191

11.4. Detalhando os commits

Casa do C√≥digo

√â poss√≠vel reverter algum dos commits facilmente, bastando para isso clicar no commit, e na tela de detalhamento do commit clicar no bot√£o revert:

Figura 11.14: Bot√£o para reverter o commit

Ap√≥s clicar no bot√£o revert um novo commit ser√° efetuado automaticamente, desfazendo as altera√ß√µes do commit selecionado:

192

Casa do C√≥digo

Cap√≠tulo 11. Ap√™ndice GitHub no Windows

Figura 11.15: Tela detalhando o commit de revert

11.5

Enviando o reposit√≥rio para o GitHub

O GitHub for Windows possui integra√ß√£o com o GitHub, e nos permite com
isto o envio do nosso reposit√≥rio local para o GitHub.
Para enviar o reposit√≥rio para o GitHub basta clicar no bot√£o Publish
Repository:

Figura 11.16: Bot√£o para enviar o reposit√≥rio para o GitHub

Ao clicar no bot√£o ser√° exibida uma tela onde podemos preencher uma
descri√ß√£o detalhada do reposit√≥rio, e escolher se o reposit√≥rio dever√° ser
193

11.5. Enviando o reposit√≥rio para o GitHub

Casa do C√≥digo

privado, caso nosso usu√°rio tenha cadastro em algum dos planos pagos do
GitHub.
Ap√≥s preencher as informa√ß√µes basta clicar no bot√£o Publish moveiswindows e nosso reposit√≥rio ser√° enviado para o GitHub:

Figura 11.17: Tela com detalhes do reposit√≥rio a ser enviado para o GitHub

Se acessarmos a p√°gina do nosso usu√°rio no GitHub, veremos que o reposit√≥rio foi enviado corretamente:

194

Casa do C√≥digo

Cap√≠tulo 11. Ap√™ndice GitHub no Windows

Figura 11.18: Tela do novo reposit√≥rio no GitHub

Agora sempre que precisarmos sincronizar nossas altera√ß√µes locais com
o reposit√≥rio remoto no GitHub, basta clicarmos no bot√£o Sync:

Figura 11.19: Bot√£o para sincronizar o reposit√≥rio local com o GitHub

11.6

Trabalhando com branches

Tamb√©m √© poss√≠vel trabalhar com branches no GitHub for Windows. Na
tela principal existe um botao onde podemos gerenciar as branches do reposit√≥rio:

195

11.6. Trabalhando com branches

Casa do C√≥digo

Figura 11.20: Bot√£o para gerenciar as branches

Vamos criar uma nova branch chamada testes, clicando no bot√£o citado
anteriormente, digitando o nome testes no campo de texto da tela, e confirmar clicando no bot√£o Create testes:

Figura 11.21: Tela de cria√ß√£o da nova branch

Ap√≥s a nova branch ser criada ela j√° √© selecionada, e se clicarmos novamente no bot√£o para gerenciar as branches, veremos que agora temos duas
branches no reposit√≥rio:
196

Casa do C√≥digo

Cap√≠tulo 11. Ap√™ndice GitHub no Windows

Figura 11.22: Tela listando as branches do reposit√≥rio

Vamos alterar novamente o arquivo teste.html e em seguida efetuar
um novo commit, mas desta vez o commit dever√° ser realizado na branch
testes.
Altere o arquivo teste.html adicionando o seguinte conte√∫do:
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<title>GitHub for Windows</title>
</head>
<body>
<h1>Bem vindo!</h1>
<p>TESTE!</p>
<h2>Trabalhando com branches</h2>
</body>
</html>

E ent√£o registre a altera√ß√£o com um novo commit, certificando-se antes
que a branch testes est√° selecionada:
197

11.6. Trabalhando com branches

Casa do C√≥digo

Figura 11.23: Tela para efetuar o novo commit

Repare que ap√≥s efetuar o commit o mesmo √© exibido na listagem de commits da branch testes:

Figura 11.24: Tela listando os commits da branch testes

Mas ao mudarmos para a branch master o commit ser√° escondido, uma
vez que ele foi efetuado apenas na branch testes:

198

Casa do C√≥digo

Cap√≠tulo 11. Ap√™ndice GitHub no Windows

Figura 11.25: Tela listando os commits da branch master

Efetuando o merge dos commits
No GitHub for Windows tamb√©m √© poss√≠vel efetuar merges, para mesclar
as altera√ß√µes de duas branches distintas.
Vamos efetuar o merge da branch testes na branch master. Para isso,
devemos clicar no bot√£o de gerenciar as branches, e na tela que ser√° aberta
clicar no bot√£o Manage:

Figura 11.26: Tela com bot√£o Manage

Ao clicar neste bot√£o veremos a tela de gerenciamento das branches do
reposit√≥rio, na qual ser√£o listadas todas as branches existentes, e na parte in199

11.6. Trabalhando com branches

Casa do C√≥digo

ferior existem dois campos utilizados para fazer o merge:

Figura 11.27: Tela de gerenciamento de branches

Para realizar o merge devemos arrastar e soltar as branches desejadas nos
campos citados anteriormente, sendo que no nosso caso a branch testes
deve ser arrastada para o primeiro campo e a master para o segundo
campo, pois queremos fazer o merge da branch testes na branch master:

200

Casa do C√≥digo

Cap√≠tulo 11. Ap√™ndice GitHub no Windows

Figura 11.28: Campos para sele√ß√£o das branches

Ap√≥s arrastar as branches para os campos devemos clicar no bot√£o Merge
para confirmar a opera√ß√£o, e uma mensagem ser√° exibida ao final do processo.
Agora se voltarmos para a tela principal e mudarmos para a branch
master, veremos que o commit efetuado na branch teste ser√° exibido na
listagem, confirmando assim que o merge foi efetuado com sucesso.

201

√çndice Remissivo

Casa do C√≥digo

√çndice Remissivo
git mergetool, 152
git mv, 49
Branch, 94
git pull, 67, 130
Branch remota, 114
git pull ‚Äìrebase, 130
Branches por etapa de desenvolvi- git push, 15, 65
mento, 167
git rebase, 108
Branches por funcionalidade, 162
git rebase ‚Äìcontinue, 150
git remote, 15, 64
Configura√ß√µes b√°sicas, 6
git remote add, 63
Conflito, 143
git remote remove, 64
git remote rename, 64
Ditador / Tenentes, 175
git remote set-url, 64
Feature branches, 162
git reset, 54
fork, 89
git revert, 56
Fork / Pull Request, 173
git rm, 47
git status, 9, 22
Git, 3
git
tag, 138
git add, 9, 22
GitHub, 12, 72
git branch, 94
GitHub for Windows, 179
git branch -r, 114
git checkout, 52, 98
Instala√ß√£o, 5
git clone, 17, 66
Open Source, 173, 175
git commit, 10, 29
git diff, 39
Protocolos, 68
git fetch, 123
pull request, 89
git init, 8, 20
git log, 11, 36
Reposit√≥rio remoto, 62
git merge, 106
.gitignore, 27

202

Casa do C√≥digo

√çndice Remissivo

servi√ßos de hospedagem de projetos,
72
Sistemas de Controle de Vers√£o, 2
Stage, 24
Topic branches, 162

203

